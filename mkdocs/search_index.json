{
    "docs": [
        {
            "location": "/",
            "text": "Erdos\n\n\nErdos is a graph library written in Julia. Installation is straightforward:\n\n\njulia> Pkg.add(\"Erdos\")\n\n\n\n\nErdos defines two abstract type, \nAGraph\n and \nADiGraph\n, from which all concrete undirected and directed graph types are derived.\n\n\nAll graphs  in Erdos have \n1:n\n indexed vertices, where \nn\n is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced, just defining a few basic methods.\n\n\n\n\nBasic examples\n\n\n\n\nConstructors\n\n\nBuild your first graph using the basic constructors.\n\n\njulia> using Erdos\n\njulia> g = CompleteGraph(100)\nGraph{Int64}(100, 4950)\n\njulia> g = Graph{Int32}(100)\nGraph{Int32}(100, 0)\n\njulia> g = DiGraph()\nDiGraph{Int64}(0, 0)\n\njulia> g = erdos_renyi(10,30)\nGraph{Int64}(10, 30)\n\njulia> g = random_regular_graph(10,3,seed=17)\nGraph{Int64}(10, 15).\n\n\n\n\nThe default graph and digraph types are \nGraph{Int}\n and \nDiGraph{Int}\n. Use  the \nGraph{Int32}\n type to save memory if working with very large graphs.\n\n\n\n\nQueries\n\n\njulia> g = CompleteBipartiteGraph(5,10)\nGraph{Int64}(15, 50)\n\njulia> is_bipartite(g)\ntrue\n\njulia> nv(g) # number of vertices\n15\n\njulia> ne(g) #number of edges\n50\n\njulia> has_edge(g,1,2)\nfalse\n\njulia> has_edge(g,1,6)\ntrue\n\njulia> degree(g,1)\n10\n\n\n\n\n\n\nModifiers:\n\n\njulia> g=DiGraph(10)\nDiGraph{Int64}(10, 0)\n\njulia> add_edge!(g,1,2)\ntrue\n\njulia> g\nDiGraph{Int64}(10, 1)\n\n# trying to add an edge between non-existen vertices results in a\n# (silent) failure\njulia> add_edge!(g,1,11)\nfalse\n\n# has the addition of an already existent edge\njulia> add_edge!(g,1,2)\nfalse\n\njulia> add_edge!(g,2,1)\ntrue\n\njulia> rem_edge!(g,2,1)\ntrue\n\n# returns the index of the vertex\njulia> add_vertex!(g)\n11\n\n# vertex removal will cause the switch of the last index\n# with the removed one, to keep the indexes continuity.\njulia> rem_vertex!(g,1)\ntrue\n\njulia> rem_vertex!(g,12)\nfalse\n\n\n\n\n\n\nIterators\n\n\njulia> g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\nGraph{Int64}(10, 20)\n\njulia> numedges = 0;\n\n# iterate over all edges\njulia> for e in edges(g)\n           i, j = src(e), dst(e) # source and destination of an edge\n           @assert i <= j  # default for undirected graphs\n           numedge += 1\n       end\n\njulia> ne(g) == numedge\ntrue\n\njulia> k=0;\n\njulia> for i in neighbors(g,1)\n           @assert has_edge(g, 1, i);\n           k += 1\n       end\n\njulia> degree(g, 1) == k\ntrue\n\n\n\n\n\n\nI/O\n\n\nErdos supports many standard graph formats. Here is an example with Pajek's .net format:\n\n\njulia> g = DiGraph(10,20)\nDiGraph{Int64}(10, 20)\n\njulia> writegraph(\"test.net\", g)\n1\n\njulia> h = readgraph(\"test.net\")\nDiGraph{Int64}(10, 20)\n\njulia> g == h\ntrue\n\n\n\n\n\n\nReady to explore\n\n\nRefer to the documentation to explore all the features of Erdos:\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood, k-core\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for a list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow, minimum s-t cut\n\n\nmatching:\n maximum weight matching on arbitrary graphs (through BlossomV algorithm)\n\n\ndismantling:\n collective influencer heuristic\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix, Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\nI/O formats:\n \ngraphml\n, \ngml\n, \ngexf\n, \ndot\n, \nnet\n, \ngt",
            "title": "Getting Started"
        },
        {
            "location": "/#erdos",
            "text": "Erdos is a graph library written in Julia. Installation is straightforward:  julia> Pkg.add(\"Erdos\")  Erdos defines two abstract type,  AGraph  and  ADiGraph , from which all concrete undirected and directed graph types are derived.  All graphs  in Erdos have  1:n  indexed vertices, where  n  is the number of vertices. Multi-edges are not allowed. Self-edges are experimentally supported. Provided this constraints, new graph types can be easily introduced, just defining a few basic methods.",
            "title": "Erdos"
        },
        {
            "location": "/#basic-examples",
            "text": "",
            "title": "Basic examples"
        },
        {
            "location": "/#constructors",
            "text": "Build your first graph using the basic constructors.  julia> using Erdos\n\njulia> g = CompleteGraph(100)\nGraph{Int64}(100, 4950)\n\njulia> g = Graph{Int32}(100)\nGraph{Int32}(100, 0)\n\njulia> g = DiGraph()\nDiGraph{Int64}(0, 0)\n\njulia> g = erdos_renyi(10,30)\nGraph{Int64}(10, 30)\n\njulia> g = random_regular_graph(10,3,seed=17)\nGraph{Int64}(10, 15).  The default graph and digraph types are  Graph{Int}  and  DiGraph{Int} . Use  the  Graph{Int32}  type to save memory if working with very large graphs.",
            "title": "Constructors"
        },
        {
            "location": "/#queries",
            "text": "julia> g = CompleteBipartiteGraph(5,10)\nGraph{Int64}(15, 50)\n\njulia> is_bipartite(g)\ntrue\n\njulia> nv(g) # number of vertices\n15\n\njulia> ne(g) #number of edges\n50\n\njulia> has_edge(g,1,2)\nfalse\n\njulia> has_edge(g,1,6)\ntrue\n\njulia> degree(g,1)\n10",
            "title": "Queries"
        },
        {
            "location": "/#modifiers",
            "text": "julia> g=DiGraph(10)\nDiGraph{Int64}(10, 0)\n\njulia> add_edge!(g,1,2)\ntrue\n\njulia> g\nDiGraph{Int64}(10, 1)\n\n# trying to add an edge between non-existen vertices results in a\n# (silent) failure\njulia> add_edge!(g,1,11)\nfalse\n\n# has the addition of an already existent edge\njulia> add_edge!(g,1,2)\nfalse\n\njulia> add_edge!(g,2,1)\ntrue\n\njulia> rem_edge!(g,2,1)\ntrue\n\n# returns the index of the vertex\njulia> add_vertex!(g)\n11\n\n# vertex removal will cause the switch of the last index\n# with the removed one, to keep the indexes continuity.\njulia> rem_vertex!(g,1)\ntrue\n\njulia> rem_vertex!(g,12)\nfalse",
            "title": "Modifiers:"
        },
        {
            "location": "/#iterators",
            "text": "julia> g = Graph(10,20) #erdos renyi random graph with 10 vertices and 20 edges\nGraph{Int64}(10, 20)\n\njulia> numedges = 0;\n\n# iterate over all edges\njulia> for e in edges(g)\n           i, j = src(e), dst(e) # source and destination of an edge\n           @assert i <= j  # default for undirected graphs\n           numedge += 1\n       end\n\njulia> ne(g) == numedge\ntrue\n\njulia> k=0;\n\njulia> for i in neighbors(g,1)\n           @assert has_edge(g, 1, i);\n           k += 1\n       end\n\njulia> degree(g, 1) == k\ntrue",
            "title": "Iterators"
        },
        {
            "location": "/#io",
            "text": "Erdos supports many standard graph formats. Here is an example with Pajek's .net format:  julia> g = DiGraph(10,20)\nDiGraph{Int64}(10, 20)\n\njulia> writegraph(\"test.net\", g)\n1\n\njulia> h = readgraph(\"test.net\")\nDiGraph{Int64}(10, 20)\n\njulia> g == h\ntrue",
            "title": "I/O"
        },
        {
            "location": "/#ready-to-explore",
            "text": "Refer to the documentation to explore all the features of Erdos:   core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood, k-core  operators:  complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)  shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for a list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow, minimum s-t cut  matching:  maximum weight matching on arbitrary graphs (through BlossomV algorithm)  dismantling:  collective influencer heuristic  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix, Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  I/O formats:   graphml ,  gml ,  gexf ,  dot ,  net ,  gt",
            "title": "Ready to explore"
        },
        {
            "location": "/types/",
            "text": "Types and Constructors\n\n\nErdos.jl\n defines the following basic types and functionalities.\n\n\n\n\nAbstract Types\n\n\n#\n\n\nErdos.AGraph\n \u2014 \nType\n.\n\n\n@compat abstract type AGraph end\n\n\n\n\nAbstract undirected graph type\n\n\nsource\n\n\n#\n\n\nErdos.ADiGraph\n \u2014 \nType\n.\n\n\nabstract ADiGraph\n\n\n\n\nAbstract directed graph type\n\n\nsource\n\n\n#\n\n\nErdos.ASimpleGraph\n \u2014 \nConstant\n.\n\n\n@compat const ASimpleGraph = Union{AGraph, ADiGraph}\n\n\n\n\nUnion of \nAGraph\n and \nADiGraph\n.\n\n\nsource\n\n\n#\n\n\nErdos.AEdge\n \u2014 \nType\n.\n\n\nabstract AEdge\n\n\n\n\nAn abstract edge type.\n\n\nsource\n\n\n\n\nGraph / DiGraph / Edge\n\n\n#\n\n\nErdos.Graph\n \u2014 \nType\n.\n\n\ntype Graph{T<:Integer} <: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\nend\n\n\n\n\nA simple graph type based on an adjacency list.\n\n\nGraph{T}(n=0)\nGraph(n=0) = Graph{Int}(n)\n\n\n\n\nConstruct a \nGraph\n with \nn\n vertices and no edges.\n\n\nGraph{T}(adjmx::AbstractMatrix)\nGraph(adjmx::AbstractMatrix) = Graph{Int}(adjmx)\n\n\n\n\nConstruct a \nGraph{T}\n from the adjacency matrix \nadjmx\n.\n\n\nsource\n\n\n#\n\n\nErdos.DiGraph\n \u2014 \nType\n.\n\n\ntype DiGraph{T<:Integer} <: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\n    badjlist::Vector{Vector{T}}\nend\n\n\n\n\nA simple digraph type based on two adjacency lists (forward and backward).\n\n\nDiGraph{T}(n=0)\nDiGraph(n=0) = DiGraph{Int}(n)\n\n\n\n\nConstruct a \nDiGraph\n with \nn\n vertices and no edges.\n\n\nDiGraph{T}(adjmx::AbstractMatrix)\nDiGraph(adjmx::AbstractMatrix) = DiGraph{Int}(adjmx)\n\n\n\n\nConstruct a \nDiGraph\n from the adjacency matrix \nadjmx\n.\n\n\nsource\n\n\n#\n\n\nErdos.Edge\n \u2014 \nType\n.\n\n\nimmutable Edge\n    src::Int\n    dst::Int\nend\n\n\n\n\nA type representing an edge between two vertices of a graph.\n\n\nsource\n\n\n\n\nGTGraph / GTDiGraph / GTEdge\n\n\n#\n\n\nErdos.GTGraph\n \u2014 \nType\n.\n\n\ntype GTGraph <: AGraph\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist\n    keep_epos::Bool                # keep updated epos\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\nend\n\n\n\n\nA type representing an directed graph with indexed edges.\n\n\nGTDiGraph(n=0)\n\n\n\n\nConstruct a \nGTDiGraph\n with \nn\n vertices and no edges.\n\n\nGTDiGraph(adjmx::AbstractMatrix)\n\n\n\n\nConstruct a \nGTDiGraph\n from the adjacency matrix \nadjmx\n.\n\n\nsource\n\n\n#\n\n\nErdos.GTDiGraph\n \u2014 \nType\n.\n\n\ntype GTDiGraph <: ADiGraph\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist\n    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist\n    keep_epos::Bool               # keep updated epos\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\nend\n\n\n\n\nA type representing an directed graph with indexed edges.\n\n\nGTDiGraph(n=0)\n\n\n\n\nConstruct a \nGTDiGraph\n with \nn\n vertices and no edges.\n\n\nGTDiGraph(adjmx::AbstractMatrix)\n\n\n\n\nConstruct a \nGTDiGraph\n from the adjacency matrix \nadjmx\n.\n\n\nsource\n\n\n#\n\n\nErdos.GTEdge\n \u2014 \nType\n.\n\n\nimmutable GTEdge <: AEdge\n    src::Int\n    dst::Int\n    idx::Int\nend\n\n\n\n\nAn indexed edge type\n\n\nGTEdge(u, v) = GTEdge(u,v,-1)\n\n\n\n\nCreates an edge with unvalid index.\n\n\nsource\n\n\n\n\nDefining new types\n\n\nIn order to define a custom graph type, e.g. \nMyGraph <: AGraph\n, some guarantee have to be respected and some method have to be exposed. Take a look to the files in \nsrc/factory/\n for some examples. Custom edges, e.g. \nMyEdge <: AEdge\n,  have to expose \nsrc(e)\n and \ndst(e)\n methods.\n\n\nGuarantees\n:\n\n\n\n\nvertices are integers in 1:nv(g)\n\n\n\n\nMandatory methods\n:\n\n\n\n\nbasic constructors (e.g. MyGraph(n), MyGraph())\n\n\nnv(g)\n\n\nne(g)\n\n\nout_neighbors(g, v)\n\n\nin_neighbors(g, v) #digraph\n\n\nedge(g, u, v)\n\n\nadd_edge!(g, u, v)\n\n\nrem_edge!(g, u, v)\n\n\nadd_vertex!(g)\n\n\npop_vertex!(g)\n\n\ngraphtype(g)\n\n\ndigraphtype(g)\n\n\nedgetype(g)\n\n\nvertextype(g)\n\n\n\n\nSome methods have general fallbacks relying on the more foundamental API described above, but could probably made more efficient knowing the internal implementation of the graph.\n\n\nReccomended overrides\n:\n\n\n\n\nin_adjlist(g) #digraph\n\n\nout_adjlist(g)\n\n\nhas_edge(g, u, v)\n\n\n==(g, h)\n\n\nout_edges(g, u)\n\n\nin_edges(g, u) # digraph\n\n\nrem_edge!(g, e)\n\n\ngraph(dg)\n\n\ndigraph(g)\n\n\nreverse!(g) #digraph\n\n\nunsafe_add_edge!(g, u, v)\n\n\nrebuild!(g)\n\n\nrem_vertex!(g, v)",
            "title": "Types and Constructors"
        },
        {
            "location": "/types/#types-and-constructors",
            "text": "Erdos.jl  defines the following basic types and functionalities.",
            "title": "Types and Constructors"
        },
        {
            "location": "/types/#abstract-types",
            "text": "#  Erdos.AGraph  \u2014  Type .  @compat abstract type AGraph end  Abstract undirected graph type  source  #  Erdos.ADiGraph  \u2014  Type .  abstract ADiGraph  Abstract directed graph type  source  #  Erdos.ASimpleGraph  \u2014  Constant .  @compat const ASimpleGraph = Union{AGraph, ADiGraph}  Union of  AGraph  and  ADiGraph .  source  #  Erdos.AEdge  \u2014  Type .  abstract AEdge  An abstract edge type.  source",
            "title": "Abstract Types"
        },
        {
            "location": "/types/#graph-digraph-edge",
            "text": "#  Erdos.Graph  \u2014  Type .  type Graph{T<:Integer} <: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\nend  A simple graph type based on an adjacency list.  Graph{T}(n=0)\nGraph(n=0) = Graph{Int}(n)  Construct a  Graph  with  n  vertices and no edges.  Graph{T}(adjmx::AbstractMatrix)\nGraph(adjmx::AbstractMatrix) = Graph{Int}(adjmx)  Construct a  Graph{T}  from the adjacency matrix  adjmx .  source  #  Erdos.DiGraph  \u2014  Type .  type DiGraph{T<:Integer} <: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{T}}\n    badjlist::Vector{Vector{T}}\nend  A simple digraph type based on two adjacency lists (forward and backward).  DiGraph{T}(n=0)\nDiGraph(n=0) = DiGraph{Int}(n)  Construct a  DiGraph  with  n  vertices and no edges.  DiGraph{T}(adjmx::AbstractMatrix)\nDiGraph(adjmx::AbstractMatrix) = DiGraph{Int}(adjmx)  Construct a  DiGraph  from the adjacency matrix  adjmx .  source  #  Erdos.Edge  \u2014  Type .  immutable Edge\n    src::Int\n    dst::Int\nend  A type representing an edge between two vertices of a graph.  source",
            "title": "Graph / DiGraph / Edge"
        },
        {
            "location": "/types/#gtgraph-gtdigraph-gtedge",
            "text": "#  Erdos.GTGraph  \u2014  Type .  type GTGraph <: AGraph\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered adjlist\n    keep_epos::Bool                # keep updated epos\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\nend  A type representing an directed graph with indexed edges.  GTDiGraph(n=0)  Construct a  GTDiGraph  with  n  vertices and no edges.  GTDiGraph(adjmx::AbstractMatrix)  Construct a  GTDiGraph  from the adjacency matrix  adjmx .  source  #  Erdos.GTDiGraph  \u2014  Type .  type GTDiGraph <: ADiGraph\n    ne::Int\n    edge_index_range::Int\n    out_edges::Vector{Vector{Pair{Int,Int}}}  #unordered out_adjlist\n    in_edges::Vector{Vector{Pair{Int,Int}}}  #unordered in_adjlist\n    keep_epos::Bool               # keep updated epos\n    epos::Vector{Pair{Int,Int}}    # position of the edge in out_edges\n    free_indexes::Vector{Int}       # indexes of deleted edges to be used up\n                                    # for new edges to avoid very large\n                                    # indexes, and unnecessary property map\n                                    # memory use\nend  A type representing an directed graph with indexed edges.  GTDiGraph(n=0)  Construct a  GTDiGraph  with  n  vertices and no edges.  GTDiGraph(adjmx::AbstractMatrix)  Construct a  GTDiGraph  from the adjacency matrix  adjmx .  source  #  Erdos.GTEdge  \u2014  Type .  immutable GTEdge <: AEdge\n    src::Int\n    dst::Int\n    idx::Int\nend  An indexed edge type  GTEdge(u, v) = GTEdge(u,v,-1)  Creates an edge with unvalid index.  source",
            "title": "GTGraph / GTDiGraph / GTEdge"
        },
        {
            "location": "/types/#defining-new-types",
            "text": "In order to define a custom graph type, e.g.  MyGraph <: AGraph , some guarantee have to be respected and some method have to be exposed. Take a look to the files in  src/factory/  for some examples. Custom edges, e.g.  MyEdge <: AEdge ,  have to expose  src(e)  and  dst(e)  methods.  Guarantees :   vertices are integers in 1:nv(g)   Mandatory methods :   basic constructors (e.g. MyGraph(n), MyGraph())  nv(g)  ne(g)  out_neighbors(g, v)  in_neighbors(g, v) #digraph  edge(g, u, v)  add_edge!(g, u, v)  rem_edge!(g, u, v)  add_vertex!(g)  pop_vertex!(g)  graphtype(g)  digraphtype(g)  edgetype(g)  vertextype(g)   Some methods have general fallbacks relying on the more foundamental API described above, but could probably made more efficient knowing the internal implementation of the graph.  Reccomended overrides :   in_adjlist(g) #digraph  out_adjlist(g)  has_edge(g, u, v)  ==(g, h)  out_edges(g, u)  in_edges(g, u) # digraph  rem_edge!(g, e)  graph(dg)  digraph(g)  reverse!(g) #digraph  unsafe_add_edge!(g, u, v)  rebuild!(g)  rem_vertex!(g, v)",
            "title": "Defining new types"
        },
        {
            "location": "/core/",
            "text": "Basic Interface\n\n\nErdos.jl\n defines the following basic  functionalities:\n\n\n#\n\n\nErdos.nv\n \u2014 \nFunction\n.\n\n\nnv(g)\n\n\n\n\nThe number of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.ne\n \u2014 \nFunction\n.\n\n\nne(g)\n\n\n\n\nThe number of edges in \ng\n.\n\n\nTime Complexity: O(1)\n\n\nsource\n\n\n#\n\n\nErdos.add_vertex!\n \u2014 \nFunction\n.\n\n\nadd_vertex!(g)\n\n\n\n\nAdd a new vertex to the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.add_vertices!\n \u2014 \nFunction\n.\n\n\nadd_vertices!(g, n)\n\n\n\n\nAdd \nn\n new vertices to the graph \ng\n. Returns the final number of vertices.\n\n\nsource\n\n\n#\n\n\nErdos.rem_vertex!\n \u2014 \nFunction\n.\n\n\nrem_vertex!(g, v)\n\n\n\n\nRemove the vertex \nv\n from graph \ng\n. It will change the label of the last vertex of the old graph to \nv\n.\n\n\nSee also \nrem_vertices!\n\n\nsource\n\n\n#\n\n\nErdos.pop_vertex!\n \u2014 \nFunction\n.\n\n\npop_vertex!(g)\n\n\n\n\nRemove the last vertex of \ng\n. Equivalent to rem_vertex!(g, nv(g)).\n\n\nsource\n\n\n#\n\n\nErdos.rem_vertices!\n \u2014 \nFunction\n.\n\n\nrem_vertex!(g, vs)\n\n\n\n\nRemove the vertices in \nvs\n from graph \ng\n. Returns a vector mapping the vertices in the new graph to the old ones.\n\n\nsource\n\n\n#\n\n\nErdos.has_edge\n \u2014 \nFunction\n.\n\n\nhas_edge(g, e)\nhas_edge(g, u, v)\n\n\n\n\nReturns true if the graph \ng\n has an edge \ne\n (from \nu\n to \nv\n).\n\n\nsource\n\n\n#\n\n\nErdos.src\n \u2014 \nFunction\n.\n\n\nsrc(e)\n\n\n\n\nReturns the source of an edge.\n\n\nsource\n\n\n#\n\n\nErdos.dst\n \u2014 \nFunction\n.\n\n\ndst(e)\n\n\n\n\nReturns the destination of an edge.\n\n\nsource\n\n\n#\n\n\nErdos.edge\n \u2014 \nFunction\n.\n\n\nedge(g, u, v)\n\n\n\n\nReturns an edge from 'u' to 'v'. The edge doesn't necessarily exists in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.add_edge!\n \u2014 \nFunction\n.\n\n\nadd_edge!(g, e)\n\n\n\n\nAdd to \ng\n the edge \ne\n.\n\n\nadd_edge!(g, u, v)\n\n\n\n\nAdd to \ng\n an edge from \nu\n to \nv\n.\n\n\nWill return false if add fails (e.g., if vertices are not in the graph or the edge is already present) and true otherwise.\n\n\nsource\n\n\n#\n\n\nErdos.unsafe_add_edge!\n \u2014 \nFunction\n.\n\n\nunsafe_add_edge!(g, u, v)\n\n\n\n\nPossibly faster and unsafer version of \nadd_edge!\n, which doesn't guarantee some graph invariant properties.\n\n\nFor example, some graph types (e.g. \nGraph\n) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such \nhas_edge(g, u, v)\n could give incorrect results.\n\n\nTo restore the correct behaviour, call \nrebuild!\n(g) after the last call to \nunsafe_add_edge!\n.\n\n\nsource\n\n\n#\n\n\nErdos.rebuild!\n \u2014 \nFunction\n.\n\n\nrebuild!(g)\n\n\n\n\nCheck and restore the structure of \ng\n, which could be corrupted by the use of unsafe functions (e. g. \nunsafe_add_edge!\n)\n\n\nsource\n\n\n#\n\n\nErdos.rem_edge!\n \u2014 \nFunction\n.\n\n\nrem_edge!(g, e)\n\n\n\n\nRemove the edge \ne\n.\n\n\nrem_edge!(g, u, v)\n\n\n\n\nRemove the edge from \nu\n to \nv\n.\n\n\nReturns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.\n\n\nsource\n\n\n#\n\n\nErdos.degree\n \u2014 \nFunction\n.\n\n\ndegree(g, v)\n\n\n\n\nReturn the number of edges  from the vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.in_degree\n \u2014 \nFunction\n.\n\n\nin_degree(g, v)\n\n\n\n\nReturns the number of edges which start at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.out_degree\n \u2014 \nFunction\n.\n\n\nout_degree(g, v)\n\n\n\n\nReturns the number of edges which end at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.neighbors\n \u2014 \nFunction\n.\n\n\nneighbors(g, v)\n\n\n\n\nReturns a list of all neighbors from vertex \nv\n in \ng\n.\n\n\nFor directed graph, this is equivalent to \nout_neighbors\n(g, v).\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.in_neighbors\n \u2014 \nFunction\n.\n\n\nin_neighbors(g, v)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an incoming edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.out_neighbors\n \u2014 \nFunction\n.\n\n\nout_neighbors(g::ASimpleGraph, v)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an outgoing edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nErdos.all_neighbors\n \u2014 \nFunction\n.\n\n\nall_neighbors(g, v)\n\n\n\n\nIterates over all distinct in/out neighbors of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.edges\n \u2014 \nFunction\n.\n\n\nedges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nIt is equivalent to \nout_edges\n.\n\n\nFor digraphs, use \nall_edges\n to iterate over both in and out edges.\n\n\nsource\n\n\nedges(g)\n\n\n\n\nReturns an iterator to the edges of a graph \ng\n. The returned iterator is invalidated by changes to \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.in_edges\n \u2014 \nFunction\n.\n\n\nin_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n going to vertex \nv\n. \nv == dst(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nErdos.out_edges\n \u2014 \nFunction\n.\n\n\nout_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nErdos.all_edges\n \u2014 \nFunction\n.\n\n\nall_edges(g, v)\n\n\n\n\nIterates over all in and out edges of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.swap_vertices!\n \u2014 \nFunction\n.\n\n\nswap_vertices!(g, u, v)\n\n\n\n\nSwap the labels of vertices \nu\n and \nv\n In the new graph all old neighbors of vertex \nn\n will be neighbors of \nv\n and viceversa.\n\n\nsource\n\n\n#\n\n\nErdos.has_vertex\n \u2014 \nFunction\n.\n\n\nhas_vertex(g, v)\n\n\n\n\nReturn true if \nv\n is a vertex of \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.is_directed\n \u2014 \nFunction\n.\n\n\nis_directed(g)\n\n\n\n\nCheck if \ng\n a graph with directed edges.\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \u2014 \nFunction\n.\n\n\nreverse(e)\n\n\n\n\nReturns an edge with swapped \nsrc(e)\n and \ndst(e)\n.\n\n\nsource\n\n\nreverse(g::ADiGraph)\n\n\n\n\nProduces a graph where all edges are reversed from the original.\n\n\nsource\n\n\nreverse(e::Edge)\n\n\n\n\nSwap \ne.src\n and \ne.dst\n.\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \u2014 \nFunction\n.\n\n\nreverse!(g::DiGraph)\n\n\n\n\nIn-place reverse (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nErdos.is_ordered\n \u2014 \nFunction\n.\n\n\nis_ordered(e)\n\n\n\n\nReturns  \nsrc(e) <= dst(e)\n.\n\n\nsource\n\n\n#\n\n\nErdos.adjacency_list\n \u2014 \nFunction\n.\n\n\nadjacency_list(g::AGraph)\nadjacency_list(g::ADiGraph, dir=:out)\n\n\n\n\nReturns the adjacency list \na\n of a graph (a vector of vector of ints). The \ni\n-th element of the adjacency list is a vector containing the neighbors of \ni\n in \ng\n.\n\n\nFor directed graphs a second optional argument can be specified (\n:out\n or \n:in\n). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.\n\n\nThe elements of  \na[i]\n have the same order as in the iterator \n(out_/in_)neighbors(g,i)\n.\n\n\nAttention\n: For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.\n\n\nsource\n\n\n#\n\n\nErdos.clean_vertex!\n \u2014 \nFunction\n.\n\n\nclean_vertex!(g, v)\n\n\n\n\nRemove all incident edges on vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.density\n \u2014 \nFunction\n.\n\n\ndensity(g)\n\n\n\n\nDensity is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.\n\n\nsource\n\n\n#\n\n\nErdos.vertices\n \u2014 \nFunction\n.\n\n\nvertices(g)\n\n\n\n\nReturns an iterator to the vertices of a graph (i.e. 1:nv(g))\n\n\nsource\n\n\n#\n\n\nErdos.has_self_loops\n \u2014 \nFunction\n.\n\n\nhas_self_loops(g)\n\n\n\n\nReturns true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nErdos.num_self_loops\n \u2014 \nFunction\n.\n\n\nnum_self_loops(g)\n\n\n\n\nReturns the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.is_graphical\n \u2014 \nFunction\n.\n\n\nis_graphical(degs::Vector{Int})\n\n\n\n\nCheck whether the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nTime complexity: O(length(degs)^2)\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \u2014 \nFunction\n.\n\n\ngraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a graph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\ngraph(s::Symbol, G = Graph)\n\n\n\n\nCreates a notorious graph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.digraph\n \u2014 \nFunction\n.\n\n\ndigraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a digraph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\ndigraph(s::Symbol, G = DiGraph)\n\n\n\n\nCreates a notorious digraph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.edgetype\n \u2014 \nFunction\n.\n\n\nedgetype(g)\nedgetype(G)\n\n\n\n\nReturns the type of edges of graph \ng\n (or graph type \nG\n), i. e. the element type returned of the iterator \nedges(g)\n.\n\n\nsource\n\n\n#\n\n\nErdos.vertextype\n \u2014 \nFunction\n.\n\n\nvertextype(g)\nvertextype(G)\n\n\n\n\nReturns the integer type of vertices of graph \ng\n (or graph type \nG\n).\n\n\nsource\n\n\n#\n\n\nErdos.graphtype\n \u2014 \nFunction\n.\n\n\ngraphtype{G<:ASimpleGraph}(::Type{G})\n\n\n\n\nThe graph type corresponding to \nG\n. If \nG<:AGraph\n returns \nG\n, if \nG<:ADiGraph\n returns a type \nH<:AGraph\n.\n\n\nsource\n\n\n#\n\n\nErdos.digraphtype\n \u2014 \nFunction\n.\n\n\ndigraphtype{G<:ASimpleGraph}(::Type{G})\n\n\n\n\nThe digraph type corresponding to \nG\n. If \nG<:ADiGraph\n returns \nG\n, if \nG<:AGraph\n returns a type \nH<:ADiGraph\n.\n\n\nsource",
            "title": "Basic Interface"
        },
        {
            "location": "/core/#basic-interface",
            "text": "Erdos.jl  defines the following basic  functionalities:  #  Erdos.nv  \u2014  Function .  nv(g)  The number of vertices in  g .  source  #  Erdos.ne  \u2014  Function .  ne(g)  The number of edges in  g .  Time Complexity: O(1)  source  #  Erdos.add_vertex!  \u2014  Function .  add_vertex!(g)  Add a new vertex to the graph  g .  source  #  Erdos.add_vertices!  \u2014  Function .  add_vertices!(g, n)  Add  n  new vertices to the graph  g . Returns the final number of vertices.  source  #  Erdos.rem_vertex!  \u2014  Function .  rem_vertex!(g, v)  Remove the vertex  v  from graph  g . It will change the label of the last vertex of the old graph to  v .  See also  rem_vertices!  source  #  Erdos.pop_vertex!  \u2014  Function .  pop_vertex!(g)  Remove the last vertex of  g . Equivalent to rem_vertex!(g, nv(g)).  source  #  Erdos.rem_vertices!  \u2014  Function .  rem_vertex!(g, vs)  Remove the vertices in  vs  from graph  g . Returns a vector mapping the vertices in the new graph to the old ones.  source  #  Erdos.has_edge  \u2014  Function .  has_edge(g, e)\nhas_edge(g, u, v)  Returns true if the graph  g  has an edge  e  (from  u  to  v ).  source  #  Erdos.src  \u2014  Function .  src(e)  Returns the source of an edge.  source  #  Erdos.dst  \u2014  Function .  dst(e)  Returns the destination of an edge.  source  #  Erdos.edge  \u2014  Function .  edge(g, u, v)  Returns an edge from 'u' to 'v'. The edge doesn't necessarily exists in  g .  source  #  Erdos.add_edge!  \u2014  Function .  add_edge!(g, e)  Add to  g  the edge  e .  add_edge!(g, u, v)  Add to  g  an edge from  u  to  v .  Will return false if add fails (e.g., if vertices are not in the graph or the edge is already present) and true otherwise.  source  #  Erdos.unsafe_add_edge!  \u2014  Function .  unsafe_add_edge!(g, u, v)  Possibly faster and unsafer version of  add_edge! , which doesn't guarantee some graph invariant properties.  For example, some graph types (e.g.  Graph ) assume sorted adjacency lists as members. In this case order is not preserved while inserting new edges, resulting in a faster construction of the graph. As a consequence though, some functions such  has_edge(g, u, v)  could give incorrect results.  To restore the correct behaviour, call  rebuild! (g) after the last call to  unsafe_add_edge! .  source  #  Erdos.rebuild!  \u2014  Function .  rebuild!(g)  Check and restore the structure of  g , which could be corrupted by the use of unsafe functions (e. g.  unsafe_add_edge! )  source  #  Erdos.rem_edge!  \u2014  Function .  rem_edge!(g, e)  Remove the edge  e .  rem_edge!(g, u, v)  Remove the edge from  u  to  v .  Returns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.  source  #  Erdos.degree  \u2014  Function .  degree(g, v)  Return the number of edges  from the vertex  v .  source  #  Erdos.in_degree  \u2014  Function .  in_degree(g, v)  Returns the number of edges which start at vertex  v .  source  #  Erdos.out_degree  \u2014  Function .  out_degree(g, v)  Returns the number of edges which end at vertex  v .  source  #  Erdos.neighbors  \u2014  Function .  neighbors(g, v)  Returns a list of all neighbors from vertex  v  in  g .  For directed graph, this is equivalent to  out_neighbors (g, v).  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.in_neighbors  \u2014  Function .  in_neighbors(g, v)  Returns an iterable to all neighbors connected to vertex  v  by an incoming edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.out_neighbors  \u2014  Function .  out_neighbors(g::ASimpleGraph, v)  Returns an iterable to all neighbors connected to vertex  v  by an outgoing edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  Erdos.all_neighbors  \u2014  Function .  all_neighbors(g, v)  Iterates over all distinct in/out neighbors of vertex  v  in  g .  source  #  Erdos.edges  \u2014  Function .  edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  It is equivalent to  out_edges .  For digraphs, use  all_edges  to iterate over both in and out edges.  source  edges(g)  Returns an iterator to the edges of a graph  g . The returned iterator is invalidated by changes to  g .  source  #  Erdos.in_edges  \u2014  Function .  in_edges(g, v)  Returns an iterator to the edges in  g  going to vertex  v .  v == dst(e)  for each returned edge  e .  source  #  Erdos.out_edges  \u2014  Function .  out_edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  source  #  Erdos.all_edges  \u2014  Function .  all_edges(g, v)  Iterates over all in and out edges of vertex  v  in  g .  source  #  Erdos.swap_vertices!  \u2014  Function .  swap_vertices!(g, u, v)  Swap the labels of vertices  u  and  v  In the new graph all old neighbors of vertex  n  will be neighbors of  v  and viceversa.  source  #  Erdos.has_vertex  \u2014  Function .  has_vertex(g, v)  Return true if  v  is a vertex of  g .  source  #  Erdos.is_directed  \u2014  Function .  is_directed(g)  Check if  g  a graph with directed edges.  source  #  Base.reverse  \u2014  Function .  reverse(e)  Returns an edge with swapped  src(e)  and  dst(e) .  source  reverse(g::ADiGraph)  Produces a graph where all edges are reversed from the original.  source  reverse(e::Edge)  Swap  e.src  and  e.dst .  source  #  Base.reverse!  \u2014  Function .  reverse!(g::DiGraph)  In-place reverse (modifies the original graph).  source  #  Erdos.is_ordered  \u2014  Function .  is_ordered(e)  Returns   src(e) <= dst(e) .  source  #  Erdos.adjacency_list  \u2014  Function .  adjacency_list(g::AGraph)\nadjacency_list(g::ADiGraph, dir=:out)  Returns the adjacency list  a  of a graph (a vector of vector of ints). The  i -th element of the adjacency list is a vector containing the neighbors of  i  in  g .  For directed graphs a second optional argument can be specified ( :out  or  :in ). The neighbors in the returned adjacency list are considered accordingly as those related through outgoing or incoming edges.  The elements of   a[i]  have the same order as in the iterator  (out_/in_)neighbors(g,i) .  Attention : For some graph types it returns a reference, not a copy, therefore the returned object should not be modified.  source  #  Erdos.clean_vertex!  \u2014  Function .  clean_vertex!(g, v)  Remove all incident edges on vertex  v  in  g .  source  #  Erdos.density  \u2014  Function .  density(g)  Density is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.  source  #  Erdos.vertices  \u2014  Function .  vertices(g)  Returns an iterator to the vertices of a graph (i.e. 1:nv(g))  source  #  Erdos.has_self_loops  \u2014  Function .  has_self_loops(g)  Returns true if  g  has any self loops.  source  #  Erdos.num_self_loops  \u2014  Function .  num_self_loops(g)  Returns the number of self loops in  g .  source  #  Erdos.is_graphical  \u2014  Function .  is_graphical(degs::Vector{Int})  Check whether the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Time complexity: O(length(degs)^2)  source  #  Erdos.graph  \u2014  Function .  graph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a graph with  n  vertices, type  G , and given  edgelist .  source  graph(s::Symbol, G = Graph)  Creates a notorious graph  s  of type  G . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source  #  Erdos.digraph  \u2014  Function .  digraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a digraph with  n  vertices, type  G , and given  edgelist .  source  digraph(s::Symbol, G = DiGraph)  Creates a notorious digraph  s  of type  G . Admissible values for  s  are:     s  graph type      :truncatedtetrahedron  A skeleton of the  truncated tetrahedron digraph .     source  #  Erdos.edgetype  \u2014  Function .  edgetype(g)\nedgetype(G)  Returns the type of edges of graph  g  (or graph type  G ), i. e. the element type returned of the iterator  edges(g) .  source  #  Erdos.vertextype  \u2014  Function .  vertextype(g)\nvertextype(G)  Returns the integer type of vertices of graph  g  (or graph type  G ).  source  #  Erdos.graphtype  \u2014  Function .  graphtype{G<:ASimpleGraph}(::Type{G})  The graph type corresponding to  G . If  G<:AGraph  returns  G , if  G<:ADiGraph  returns a type  H<:AGraph .  source  #  Erdos.digraphtype  \u2014  Function .  digraphtype{G<:ASimpleGraph}(::Type{G})  The digraph type corresponding to  G . If  G<:ADiGraph  returns  G , if  G<:AGraph  returns a type  H<:ADiGraph .  source",
            "title": "Basic Interface"
        },
        {
            "location": "/maps/",
            "text": "Maps\n\n\nArbitrary values can be associated to a graph's vertices and edges, and handed over to method's that necessitate them, thanks to the edge maps and vertex maps interfaces.\n\n\n\n\nEdge Maps\n\n\n#\n\n\nErdos.AEdgeMap\n \u2014 \nType\n.\n\n\nAEdgeMap{E,T}\n\n\n\n\nType representing an abstract vertex map.\n\n\nsource\n\n\n#\n\n\nErdos.ConstEdgeMap\n \u2014 \nType\n.\n\n\nimmutable ConstEdgeMap{T} <: SimpleEdgeMap{T}\n    val::T\nend\n\n\n\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. \nemap[u,v] = 4\n, will fail silently.\n\n\nsource\n\n\n#\n\n\nErdos.EdgeMap\n \u2014 \nType\n.\n\n\ntype EdgeMap{E,T,D} <: AEdgeMap{E,T}\n    data::D\n    etype::Type{E}\n    vtype::Type{T}\nend\n\n\n\n\nType implementing an edge map. The underlying container \ndata\n can be a \nDict\n or an \nAbstractMatrix\n.\n\n\nsource\n\n\n#\n\n\nErdos.EdgeMap\n \u2014 \nMethod\n.\n\n\nEdgeMap{T}(g, ::Type{T})\n\n\n\n\nReturns a map that associates values of type \nT\n to the vertices of  graph \ng\n.\n\n\nsource\n\n\n\n\nVertex Maps\n\n\nAny \nAbstractVector{T}\n or \nDict{Int,T}\n can be used as a vertex map.\n\n\n#\n\n\nErdos.AVertexMap\n \u2014 \nConstant\n.\n\n\n@compat const AVertexMap{V,T} = Union{AbstractVector{T}, Dict{V,T}}\n\n\n\n\nType representing an abstract vertex map.\n\n\nsource\n\n\n#\n\n\nErdos.ConstVertexMap\n \u2014 \nType\n.\n\n\nimmutable ConstVertexMap{T} <: AbstractVector{T}\n    val::T\nend\n\n\n\n\nA type representing a constant vector map. Any attempt to change the internal value, e.g. \nvm[1] = 4\n, will fail silently.\n\n\nsource\n\n\n#\n\n\nErdos.VertexMap\n \u2014 \nMethod\n.\n\n\nVertexMap{T}(g, ::Type{T})\n\n\n\n\nReturns a map that associates values of type \nT\n to the vertices of  graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.hasindex\n \u2014 \nMethod\n.\n\n\nhasindex(v, i::Integer)\n\n\n\n\nCheck if collection \nv\n is indexable by \ni\n\n\nsource",
            "title": "Maps"
        },
        {
            "location": "/maps/#maps",
            "text": "Arbitrary values can be associated to a graph's vertices and edges, and handed over to method's that necessitate them, thanks to the edge maps and vertex maps interfaces.",
            "title": "Maps"
        },
        {
            "location": "/maps/#edge-maps",
            "text": "#  Erdos.AEdgeMap  \u2014  Type .  AEdgeMap{E,T}  Type representing an abstract vertex map.  source  #  Erdos.ConstEdgeMap  \u2014  Type .  immutable ConstEdgeMap{T} <: SimpleEdgeMap{T}\n    val::T\nend  A type representing a constant vector map. Any attempt to change the internal value, e.g.  emap[u,v] = 4 , will fail silently.  source  #  Erdos.EdgeMap  \u2014  Type .  type EdgeMap{E,T,D} <: AEdgeMap{E,T}\n    data::D\n    etype::Type{E}\n    vtype::Type{T}\nend  Type implementing an edge map. The underlying container  data  can be a  Dict  or an  AbstractMatrix .  source  #  Erdos.EdgeMap  \u2014  Method .  EdgeMap{T}(g, ::Type{T})  Returns a map that associates values of type  T  to the vertices of  graph  g .  source",
            "title": "Edge Maps"
        },
        {
            "location": "/maps/#vertex-maps",
            "text": "Any  AbstractVector{T}  or  Dict{Int,T}  can be used as a vertex map.  #  Erdos.AVertexMap  \u2014  Constant .  @compat const AVertexMap{V,T} = Union{AbstractVector{T}, Dict{V,T}}  Type representing an abstract vertex map.  source  #  Erdos.ConstVertexMap  \u2014  Type .  immutable ConstVertexMap{T} <: AbstractVector{T}\n    val::T\nend  A type representing a constant vector map. Any attempt to change the internal value, e.g.  vm[1] = 4 , will fail silently.  source  #  Erdos.VertexMap  \u2014  Method .  VertexMap{T}(g, ::Type{T})  Returns a map that associates values of type  T  to the vertices of  graph  g .  source  #  Erdos.hasindex  \u2014  Method .  hasindex(v, i::Integer)  Check if collection  v  is indexable by  i  source",
            "title": "Vertex Maps"
        },
        {
            "location": "/operators/",
            "text": "Operators\n\n\nErdos.jl\n implements the following graph operators:\n\n\n\n\nBase.SparseArrays.blkdiag\n\n\nBase.intersect\n\n\nBase.join\n\n\nBase.union\n\n\nErdos.cartesian_product\n\n\nErdos.complement\n\n\nErdos.complete\n\n\nErdos.complete!\n\n\nErdos.crosspath\n\n\nErdos.difference\n\n\nErdos.egonet\n\n\nErdos.subgraph\n\n\nErdos.symmetric_difference\n\n\nErdos.tensor_product\n\n\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \u2014 \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nProduces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.\n\n\nPut simply, the vertices and edges from graph \nh\n are appended to graph \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \u2014 \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nProduces a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nBase.join\n \u2014 \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between  the vertices in \ng\n and those in \nh\n.\n\n\nsource\n\n\n#\n\n\nBase.union\n \u2014 \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nsource\n\n\n#\n\n\nErdos.cartesian_product\n \u2014 \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource\n\n\n#\n\n\nErdos.complement\n \u2014 \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nProduces the \ngraph complement\n of a graph.\n\n\nsource\n\n\n#\n\n\nErdos.complete!\n \u2014 \nMethod\n.\n\n\ncomplete!(g::ADiGraph)\n\n\n\n\nReturns a digraph containing both the edges \n(u,v)\n of \ng\n and their reverse \n(v,u)\n.\n\n\nsource\n\n\n#\n\n\nErdos.complete\n \u2014 \nMethod\n.\n\n\ncomplete(g::ADiGraph)\n\n\n\n\nReturns a digraph containing both the edges \n(u,v)\n of \ng\n and their reverse \n(v,u)\n.\n\n\nsource\n\n\n#\n\n\nErdos.crosspath\n \u2014 \nMethod\n.\n\n\ncrosspath(len::Integer, g::AGraph)\n\n\n\n\nReplicate \nlen\n times \nh\n and connect each vertex with its copies in a path\n\n\nsource\n\n\n#\n\n\nErdos.difference\n \u2014 \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nProduces a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nErdos.egonet\n \u2014 \nMethod\n.\n\n\negonet(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered. This is equivalent to \nsubgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nsource\n\n\n#\n\n\nErdos.subgraph\n \u2014 \nMethod\n.\n\n\nsubgraph(g, vlist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the vertices in  \nvlist\n.\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nReturns  also a vector \nvmap\n mapping the new vertices to the old ones: the  vertex \ni\n in the subgraph corresponds to the vertex \nvmap[i]\n in \ng\n.\n\n\nsubgraph(g, elist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the edges in \nelist\n, along with the associated vector \nvmap\n mapping new vertices to the old ones.\n\n\nUsage Examples:\n\n\ng = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nErdos.symmetric_difference\n \u2014 \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nProduces a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nErdos.tensor_product\n \u2014 \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource",
            "title": "Operators"
        },
        {
            "location": "/operators/#operators",
            "text": "Erdos.jl  implements the following graph operators:   Base.SparseArrays.blkdiag  Base.intersect  Base.join  Base.union  Erdos.cartesian_product  Erdos.complement  Erdos.complete  Erdos.complete!  Erdos.crosspath  Erdos.difference  Erdos.egonet  Erdos.subgraph  Erdos.symmetric_difference  Erdos.tensor_product   #  Base.SparseArrays.blkdiag  \u2014  Method .  blkdiag(g, h)  Produces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.  Put simply, the vertices and edges from graph  h  are appended to graph  g .  source  #  Base.intersect  \u2014  Method .  intersect(g, h)  Produces a graph with edges that are only in both graph  g  and graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Base.join  \u2014  Method .  join(g, h)  Merges graphs  g  and  h  using  blkdiag  and then adds all the edges between  the vertices in  g  and those in  h .  source  #  Base.union  \u2014  Method .  union(g, h)  Merges graphs  g  and  h  by taking the set union of all vertices and edges.  source  #  Erdos.cartesian_product  \u2014  Method .  cartesian_product(g, h)  Returns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source  #  Erdos.complement  \u2014  Method .  complement(g)  Produces the  graph complement  of a graph.  source  #  Erdos.complete!  \u2014  Method .  complete!(g::ADiGraph)  Returns a digraph containing both the edges  (u,v)  of  g  and their reverse  (v,u) .  source  #  Erdos.complete  \u2014  Method .  complete(g::ADiGraph)  Returns a digraph containing both the edges  (u,v)  of  g  and their reverse  (v,u) .  source  #  Erdos.crosspath  \u2014  Method .  crosspath(len::Integer, g::AGraph)  Replicate  len  times  h  and connect each vertex with its copies in a path  source  #  Erdos.difference  \u2014  Method .  difference(g, h)  Produces a graph with edges in graph  g  that are not in graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Erdos.egonet  \u2014  Method .  egonet(g, v::Int, d::Int; dir=:out)  Returns the subgraph of  g  induced by the neighbors of  v  up to distance  d . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered. This is equivalent to  subgraph (g, neighborhood(g, v, d, dir=dir))[1].  source  #  Erdos.subgraph  \u2014  Method .  subgraph(g, vlist)  Returns the subgraph of  g  induced by the vertices in   vlist .  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  Returns  also a vector  vmap  mapping the new vertices to the old ones: the  vertex  i  in the subgraph corresponds to the vertex  vmap[i]  in  g .  subgraph(g, elist)  Returns the subgraph of  g  induced by the edges in  elist , along with the associated vector  vmap  mapping new vertices to the old ones.  Usage Examples:  g = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]  source  #  Erdos.symmetric_difference  \u2014  Method .  symmetric_difference(g, h)  Produces a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Note that this function may produce a graph with 0-degree vertices.  source  #  Erdos.tensor_product  \u2014  Method .  tensor_product(g, h)  Returns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source",
            "title": "Operators"
        },
        {
            "location": "/traversals/",
            "text": "Path and Traversal\n\n\nErdos.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n\n\n\n#\n\n\nErdos.BreadthFirst\n \u2014 \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor < 0     => examined but not closed\n\n\ncolor > 0     => examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor == 1     => examined\n\n\n\n\nsource\n\n\n#\n\n\nErdos.bfs_tree\n \u2014 \nMethod\n.\n\n\nbfs_tree(g, s)\n\n\n\n\nProvides a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nErdos.bipartite_map\n \u2014 \nMethod\n.\n\n\nbipartite_map(g)\n\n\n\n\nIf the graph is bipartite returns a vector \nc\n  of size \nnv(g)\n containing the assignment of each vertex to one of the two sets (\nc[i] == 1\n or \nc[i]==2\n). If \ng\n is not bipartite returns an empty vector.\n\n\nsource\n\n\n#\n\n\nErdos.gdistances!\n \u2014 \nMethod\n.\n\n\ngdistances!(g, source, dists) -> dists\n\n\n\n\nFills \ndists\n with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. \ndists\n can be either a vector or a dictionary.\n\n\nsource\n\n\n#\n\n\nErdos.gdistances\n \u2014 \nMethod\n.\n\n\ngdistances(g, source) -> dists\n\n\n\n\nReturns a vector filled with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nErdos.is_bipartite\n \u2014 \nMethod\n.\n\n\nis_bipartite(g)\nis_bipartite(g, v)\n\n\n\n\nWill return \ntrue\n if graph \ng\n is \nbipartite\n. If a node \nv\n is specified, only the connected component to which it belongs is considered.\n\n\nsource\n\n\n#\n\n\nErdos.DepthFirst\n \u2014 \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor < 0     => examined but not closed\n\n\ncolor > 0     => examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor == 1     => examined\n\n\n\n\nsource\n\n\n#\n\n\nErdos.dfs_tree\n \u2014 \nMethod\n.\n\n\ndfs_tree(g, s)\n\n\n\n\nProvides a depth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nErdos.is_cyclic\n \u2014 \nMethod\n.\n\n\nis_cyclic(g)\n\n\n\n\nTests whether a graph contains a cycle through depth-first search. It returns \ntrue\n when it finds a cycle, otherwise \nfalse\n.\n\n\nsource\n\n\n#\n\n\nErdos.maximum_adjacency_visit\n \u2014 \nFunction\n.\n\n\nmaximum_adjacency_visit(\n    g,\n    distmx::AEdgeMap=ConstEdgeMap(g,1);\n    log::Bool=false,\n    io::IO=STDOUT\n)\n\n\n\n\nReturns the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n edge map may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n#\n\n\nErdos.minimum_cut\n \u2014 \nMethod\n.\n\n\nminimum_cut(g, dist_edge map=ConstEdgeMap(g,1))\n\n\n\n\nFinds the \ncut\n of minimum total weight.\n\n\nReturns a tuple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut. An optional \ndist_matrix\n edge map maybe specified; if omitted, edge distances are assumed to be 1.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nErdos\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nErdos.nonbacktracking_randomwalk\n \u2014 \nMethod\n.\n\n\nnonbacktracking_randomwalk(g, s, niter)\n\n\n\n\nPerforms a non-backtracking random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nErdos.randomwalk\n \u2014 \nMethod\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerforms a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nErdos.self_avoiding_randomwalk\n \u2014 \nMethod\n.\n\n\nself_avoiding_randomwalk(g, s, niter)\n\n\n\n\nPerforms a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\n#\n\n\nErdos.attracting_components\n \u2014 \nMethod\n.\n\n\nattracting_components(g::ADiGraph)\n\n\n\n\nReturns a vector of vectors of integers representing lists of attracting components in \ng\n. The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\n\nsource\n\n\n#\n\n\nErdos.condensation\n \u2014 \nMethod\n.\n\n\ncondensation(g::ADiGraph)\n\n\n\n\nReturns the condensation graph associated with \ng\n. The condensation \nh\n of a graph \ng\n is the directed graph where every node in \nh\n represents a strongly connected component in \ng\n, and the presence of an edge between between nodes in \nh\n indicates that there is at least one edge between the associated strongly connected components in \ng\n. The node numbering in \nh\n corresponds to the ordering of the components output from \nstrongly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nErdos.connected_components\n \u2014 \nMethod\n.\n\n\nconnected_components(g::AGraph)\n\n\n\n\nReturns the \nconnected components\n of \ng\n as a vector of components, each represented by a vector of vertices belonging to the component.\n\n\nSee also \nweakly_connected_components\n and \nstrongly_connected_components\n for directed graphs.\n\n\nsource\n\n\n#\n\n\nErdos.is_connected\n \u2014 \nMethod\n.\n\n\nis_connected(g)\n\n\n\n\nReturns \ntrue\n if \ng\n is connected. For DiGraphs, this is equivalent to a test of weak connectivity.\n\n\nsource\n\n\n#\n\n\nErdos.is_strongly_connected\n \u2014 \nMethod\n.\n\n\nis_strongly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if \ng\n is strongly connected.\n\n\nSee also \nstrongly_connected_components\n\n\nsource\n\n\n#\n\n\nErdos.is_weakly_connected\n \u2014 \nMethod\n.\n\n\nis_weakly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if the undirected graph \ng\n is weakly connected.\n\n\nSee also \nweakly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nErdos.neighborhood\n \u2014 \nMethod\n.\n\n\nneighborhood(g, v, d; dir=:out)\n\n\n\n\nReturns a vector of the vertices in \ng\n at distance less or equal to \nd\n from \nv\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered.\n\n\nsource\n\n\n#\n\n\nErdos.period\n \u2014 \nMethod\n.\n\n\nperiod(g::ADiGraph)\n\n\n\n\nComputes the common period for all nodes in a strongly connected graph.\n\n\nsource\n\n\n#\n\n\nErdos.strongly_connected_components\n \u2014 \nMethod\n.\n\n\nstrongly_connected_components(g::ADiGraph)\n\n\n\n\nComputes the strongly connected components of a directed graph.\n\n\nsource\n\n\n#\n\n\nErdos.weakly_connected_components\n \u2014 \nMethod\n.\n\n\nweakly_connected_components(g::ADiGraph)\n\n\n\n\nReturns the weakly connected components of undirected graph \ng\n. It is equivalent to the connected components of the corresponding undirected graph, i.e. \nconnected_components(graph(g))\n.\n\n\nsource",
            "title": "Traversals"
        },
        {
            "location": "/traversals/#path-and-traversal",
            "text": "Erdos.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.",
            "title": "Path and Traversal"
        },
        {
            "location": "/traversals/#graph-traversal",
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .    #  Erdos.BreadthFirst  \u2014  Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    => unseen  color < 0     => examined but not closed  color > 0     => examined and closed   EdgeColorMap :   color == 0    => unseen  color == 1     => examined   source  #  Erdos.bfs_tree  \u2014  Method .  bfs_tree(g, s)  Provides a breadth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  Erdos.bipartite_map  \u2014  Method .  bipartite_map(g)  If the graph is bipartite returns a vector  c   of size  nv(g)  containing the assignment of each vertex to one of the two sets ( c[i] == 1  or  c[i]==2 ). If  g  is not bipartite returns an empty vector.  source  #  Erdos.gdistances!  \u2014  Method .  gdistances!(g, source, dists) -> dists  Fills  dists  with the geodesic distances of vertices in   g  from vertex/vertices  source .  dists  can be either a vector or a dictionary.  source  #  Erdos.gdistances  \u2014  Method .  gdistances(g, source) -> dists  Returns a vector filled with the geodesic distances of vertices in   g  from vertex/vertices  source . For vertices in disconnected components the default distance is -1.  source  #  Erdos.is_bipartite  \u2014  Method .  is_bipartite(g)\nis_bipartite(g, v)  Will return  true  if graph  g  is  bipartite . If a node  v  is specified, only the connected component to which it belongs is considered.  source  #  Erdos.DepthFirst  \u2014  Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    => unseen  color < 0     => examined but not closed  color > 0     => examined and closed   EdgeColorMap :   color == 0    => unseen  color == 1     => examined   source  #  Erdos.dfs_tree  \u2014  Method .  dfs_tree(g, s)  Provides a depth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  Erdos.is_cyclic  \u2014  Method .  is_cyclic(g)  Tests whether a graph contains a cycle through depth-first search. It returns  true  when it finds a cycle, otherwise  false .  source  #  Erdos.maximum_adjacency_visit  \u2014  Function .  maximum_adjacency_visit(\n    g,\n    distmx::AEdgeMap=ConstEdgeMap(g,1);\n    log::Bool=false,\n    io::IO=STDOUT\n)  Returns the vertices in  g  traversed by maximum adjacency search. An optional  distmx  edge map may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source  #  Erdos.minimum_cut  \u2014  Method .  minimum_cut(g, dist_edge map=ConstEdgeMap(g,1))  Finds the  cut  of minimum total weight.  Returns a tuple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut. An optional  dist_matrix  edge map maybe specified; if omitted, edge distances are assumed to be 1.  source",
            "title": "Graph Traversal"
        },
        {
            "location": "/traversals/#random-walks",
            "text": "Erdos  includes uniform random walks and self avoiding walks:  #  Erdos.nonbacktracking_randomwalk  \u2014  Method .  nonbacktracking_randomwalk(g, s, niter)  Performs a non-backtracking random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  Erdos.randomwalk  \u2014  Method .  randomwalk(g, s, niter)  Performs a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  Erdos.self_avoiding_randomwalk  \u2014  Method .  self_avoiding_randomwalk(g, s, niter)  Performs a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source",
            "title": "Random walks"
        },
        {
            "location": "/traversals/#connectivity-bipartiteness",
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  #  Erdos.attracting_components  \u2014  Method .  attracting_components(g::ADiGraph)  Returns a vector of vectors of integers representing lists of attracting components in  g . The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.  source  #  Erdos.condensation  \u2014  Method .  condensation(g::ADiGraph)  Returns the condensation graph associated with  g . The condensation  h  of a graph  g  is the directed graph where every node in  h  represents a strongly connected component in  g , and the presence of an edge between between nodes in  h  indicates that there is at least one edge between the associated strongly connected components in  g . The node numbering in  h  corresponds to the ordering of the components output from  strongly_connected_components .  source  #  Erdos.connected_components  \u2014  Method .  connected_components(g::AGraph)  Returns the  connected components  of  g  as a vector of components, each represented by a vector of vertices belonging to the component.  See also  weakly_connected_components  and  strongly_connected_components  for directed graphs.  source  #  Erdos.is_connected  \u2014  Method .  is_connected(g)  Returns  true  if  g  is connected. For DiGraphs, this is equivalent to a test of weak connectivity.  source  #  Erdos.is_strongly_connected  \u2014  Method .  is_strongly_connected(g::ADiGraph)  Returns  true  if  g  is strongly connected.  See also  strongly_connected_components  source  #  Erdos.is_weakly_connected  \u2014  Method .  is_weakly_connected(g::ADiGraph)  Returns  true  if the undirected graph  g  is weakly connected.  See also  weakly_connected_components .  source  #  Erdos.neighborhood  \u2014  Method .  neighborhood(g, v, d; dir=:out)  Returns a vector of the vertices in  g  at distance less or equal to  d  from  v . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered.  source  #  Erdos.period  \u2014  Method .  period(g::ADiGraph)  Computes the common period for all nodes in a strongly connected graph.  source  #  Erdos.strongly_connected_components  \u2014  Method .  strongly_connected_components(g::ADiGraph)  Computes the strongly connected components of a directed graph.  source  #  Erdos.weakly_connected_components  \u2014  Method .  weakly_connected_components(g::ADiGraph)  Returns the weakly connected components of undirected graph  g . It is equivalent to the connected components of the corresponding undirected graph, i.e.  connected_components(graph(g)) .  source",
            "title": "Connectivity / Bipartiteness"
        },
        {
            "location": "/distance/",
            "text": "Distance\n\n\nErdos.jl\n includes the following distance measurements:\n\n\n#\n\n\nErdos.center\n \u2014 \nMethod\n.\n\n\ncenter(g, distmx=ConstEdgeMap(g,1))\ncenter(all_ecc)\n\n\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nEventually a vector \nall_ecc\n contain the eccentricity of each node can be passed as argument.\n\n\nSee \neccentricities\n.\n\n\nsource\n\n\n#\n\n\nErdos.diameter\n \u2014 \nFunction\n.\n\n\ndiameter(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns the maximum distance between any two vertices in \ng\n. Distances  between two adjacent nodes are given by \ndistmx\n.\n\n\nSee also \neccentricities\n, \nradius\n.\n\n\nsource\n\n\n#\n\n\nErdos.eccentricities\n \u2014 \nFunction\n.\n\n\neccentricities(g, distmx=ConstEdgeMap(g,1))\neccentricities(g, vs, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns \n[eccentricity(g,v,distmx) for v in vs]\n. When \nvs\n it is not supplied, considers all node in the graph.\n\n\nSee also \neccentricity\n.\n\n\nNote: the eccentricity vector returned by \neccentricity\n may be eventually used as input in some eccentricity related measures (\nperiphery\n, \ncenter\n).\n\n\nsource\n\n\n#\n\n\nErdos.eccentricity\n \u2014 \nFunction\n.\n\n\neccentricity(g, v, distmx=ConstEdgeMap(g,1))\n\n\n\n\nCalculates the eccentricity[ies] of a vertex \nv\n, An optional matrix of edge distances may be supplied.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nsource\n\n\n#\n\n\nErdos.periphery\n \u2014 \nMethod\n.\n\n\nperiphery(g, distmx=ConstEdgeMap(g,1))\nperiphery(all_ecc)\n\n\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nEventually a vector \nall_ecc\n contain the eccentricity of each node can be passed as argument.\n\n\nSee \neccentricities\n.\n\n\nsource\n\n\n#\n\n\nErdos.radius\n \u2014 \nFunction\n.\n\n\nradius(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nReturns the minimum distance between any two vertices in \ng\n. Distances  between two adjacent nodes are given by \ndistmx\n.\n\n\nSee \neccentricities\n, \ndiameter\n.\n\n\nsource\n\n\n#\n\n\nErdos.BoundedMinkowskiCost\n \u2014 \nMethod\n.\n\n\nSimilar to MinkowskiCost, but ensures costs smaller than 2\u03c4.\n\n\nsource\n\n\n#\n\n\nErdos.MinkowskiCost\n \u2014 \nMethod\n.\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nsource\n\n\n#\n\n\nErdos.edit_distance\n \u2014 \nMethod\n.\n\n\nedit_distance(G\u2081, G\u2082;\n       insert_cost::Function=v->1.0,\n       delete_cost::Function=u->1.0,\n       subst_cost::Function=(u,v)->0.5,\n       heuristic::Function=DefaultEditHeuristic)\n\n\n\n\nComputes the edit distance between graphs G\u2081 and G\u2082.\n\n\nReturns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:\n\n\n\n\n(0,v): insertion of vertex v \u2208 G\u2082\n\n\n(u,0): deletion of vertex u \u2208 G\u2081\n\n\n(u>0,v>0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\nA custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-\n\n\n\n\nGiven two graphs $|G\u2081| < |G\u2082|$, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are \nsymmetric\n.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nFor further details, please refer to:\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\nAuthor: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\nsource",
            "title": "Distance"
        },
        {
            "location": "/distance/#distance",
            "text": "Erdos.jl  includes the following distance measurements:  #  Erdos.center  \u2014  Method .  center(g, distmx=ConstEdgeMap(g,1))\ncenter(all_ecc)  Returns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  Eventually a vector  all_ecc  contain the eccentricity of each node can be passed as argument.  See  eccentricities .  source  #  Erdos.diameter  \u2014  Function .  diameter(g, distmx=ConstEdgeMap(g,1))  Returns the maximum distance between any two vertices in  g . Distances  between two adjacent nodes are given by  distmx .  See also  eccentricities ,  radius .  source  #  Erdos.eccentricities  \u2014  Function .  eccentricities(g, distmx=ConstEdgeMap(g,1))\neccentricities(g, vs, distmx=ConstEdgeMap(g,1))  Returns  [eccentricity(g,v,distmx) for v in vs] . When  vs  it is not supplied, considers all node in the graph.  See also  eccentricity .  Note: the eccentricity vector returned by  eccentricity  may be eventually used as input in some eccentricity related measures ( periphery ,  center ).  source  #  Erdos.eccentricity  \u2014  Function .  eccentricity(g, v, distmx=ConstEdgeMap(g,1))  Calculates the eccentricity[ies] of a vertex  v , An optional matrix of edge distances may be supplied.  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  source  #  Erdos.periphery  \u2014  Method .  periphery(g, distmx=ConstEdgeMap(g,1))\nperiphery(all_ecc)  Returns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  Eventually a vector  all_ecc  contain the eccentricity of each node can be passed as argument.  See  eccentricities .  source  #  Erdos.radius  \u2014  Function .  radius(g, distmx=ConstEdgeMap(g,1))  Returns the minimum distance between any two vertices in  g . Distances  between two adjacent nodes are given by  distmx .  See  eccentricities ,  diameter .  source  #  Erdos.BoundedMinkowskiCost  \u2014  Method .  Similar to MinkowskiCost, but ensures costs smaller than 2\u03c4.  source  #  Erdos.MinkowskiCost  \u2014  Method .  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  source  #  Erdos.edit_distance  \u2014  Method .  edit_distance(G\u2081, G\u2082;\n       insert_cost::Function=v->1.0,\n       delete_cost::Function=u->1.0,\n       subst_cost::Function=(u,v)->0.5,\n       heuristic::Function=DefaultEditHeuristic)  Computes the edit distance between graphs G\u2081 and G\u2082.  Returns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:   (0,v): insertion of vertex v \u2208 G\u2082  (u,0): deletion of vertex u \u2208 G\u2081  (u>0,v>0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))  A custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory. Performance tips: \u2013\u2013\u2013\u2013\u2013\u2013\u2013\u2013-   Given two graphs $|G\u2081| < |G\u2082|$,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are  symmetric .   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   For further details, please refer to:  RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)  Author: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)  source",
            "title": "Distance"
        },
        {
            "location": "/shortestpaths/",
            "text": "Shortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n\n\nShortest-Path Algorithms\n\n\n#\n\n\nErdos.enumerate_paths\n \u2014 \nMethod\n.\n\n\nenumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\n#\n\n\nErdos.shortest_paths\n \u2014 \nMethod\n.\n\n\nshortest_paths(g, x...; kws...)\n\n\n\n\nComputes shortest paths using Dijkstra's algorithm. See \ndijkstra_shortest_paths\n.\n\n\nsource\n\n\n#\n\n\nErdos.a_star\n \u2014 \nFunction\n.\n\n\na_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n->0)\n\n\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.\n\n\nsource\n\n\n#\n\n\nErdos.bellman_ford_shortest_paths\n \u2014 \nMethod\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths of all vertices of a \ng\n from a source vertex \ns\n (or a set of source vertices \nsources\n). Returns a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nErdos.dijkstra_shortest_paths\n \u2014 \nFunction\n.\n\n\ndijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)\n\n\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n (or a vector \nsources\n)  and all other veritces. Returns a \nDijkstraState\n that contains various traversal information.\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nErdos.floyd_warshall_shortest_paths\n \u2014 \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).\n\n\nsource\n\n\n\u2013->\n\n\n#\n\n\nErdos.a_star\n \u2014 \nFunction\n.\n\n\na_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n->0)\n\n\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.\n\n\nsource\n\n\n#\n\n\nErdos.dijkstra_shortest_paths\n \u2014 \nFunction\n.\n\n\ndijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)\n\n\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n (or a vector \nsources\n)  and all other veritces. Returns a \nDijkstraState\n that contains various traversal information.\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nErdos.bellman_ford_shortest_paths\n \u2014 \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths of all vertices of a \ng\n from a source vertex \ns\n (or a set of source vertices \nsources\n). Returns a \nBellmanFordState\n with relevant traversal information.\n\n\nsource\n\n\n#\n\n\nErdos.floyd_warshall_shortest_paths\n \u2014 \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))\n\n\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nErdos.enumerate_paths\n \u2014 \nFunction\n.\n\n\nenumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.",
            "title": "Shortest Paths"
        },
        {
            "location": "/shortestpaths/#shortest-path-algorithms",
            "text": "",
            "title": "Shortest-Path Algorithms"
        },
        {
            "location": "/shortestpaths/#general-properties-of-shortest-path-algorithms",
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .",
            "title": "General properties of shortest path algorithms"
        },
        {
            "location": "/shortestpaths/#shortest-path-algorithms_1",
            "text": "#  Erdos.enumerate_paths  \u2014  Method .  enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  #  Erdos.shortest_paths  \u2014  Method .  shortest_paths(g, x...; kws...)  Computes shortest paths using Dijkstra's algorithm. See  dijkstra_shortest_paths .  source  #  Erdos.a_star  \u2014  Function .  a_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n->0)  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.  source  #  Erdos.bellman_ford_shortest_paths  \u2014  Method .  bellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))  Uses the  Bellman-Ford algorithm  to compute shortest paths of all vertices of a  g  from a source vertex  s  (or a set of source vertices  sources ). Returns a  BellmanFordState  with relevant traversal information.  source  #  Erdos.dijkstra_shortest_paths  \u2014  Function .  dijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  (or a vector  sources )  and all other veritces. Returns a  DijkstraState  that contains various traversal information.  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex.  source  #  Erdos.floyd_warshall_shortest_paths  \u2014  Function .  floyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).  source  \u2013->  #  Erdos.a_star  \u2014  Function .  a_star(g, s, t, distmx=ConstEdgeMap(g,1), heuristic = n->0)  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied. Returns an empty path if there are no such paths.  source  #  Erdos.dijkstra_shortest_paths  \u2014  Function .  dijkstra_shortest_paths(g, s, distmx=ConstEdgeMap(g,1); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1); allpaths=false)  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  (or a vector  sources )  and all other veritces. Returns a  DijkstraState  that contains various traversal information.  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex.  source  #  Erdos.bellman_ford_shortest_paths  \u2014  Function .  bellman_ford_shortest_paths(g, s, distmx=ConstEdgeMap(g,1))\nbellman_ford_shortest_paths(g, sources, distmx=ConstEdgeMap(g,1))  Uses the  Bellman-Ford algorithm  to compute shortest paths of all vertices of a  g  from a source vertex  s  (or a set of source vertices  sources ). Returns a  BellmanFordState  with relevant traversal information.  source  #  Erdos.floyd_warshall_shortest_paths  \u2014  Function .  floyd_warshall_shortest_paths(g, distmx=ConstEdgeMap(g,1))  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).  source",
            "title": "Shortest-Path Algorithms"
        },
        {
            "location": "/shortestpaths/#path-discovery-enumeration",
            "text": "#  Erdos.enumerate_paths  \u2014  Function .  enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .",
            "title": "Path discovery / enumeration"
        },
        {
            "location": "/shortestpaths/#path-states",
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.",
            "title": "Path States"
        },
        {
            "location": "/linalg/",
            "text": "Linear Algebra\n\n\nErdos.jl\n provides the following matrix operations on both directed and undirected graphs:\n\n\n#\n\n\nErdos.adjacency_matrix\n \u2014 \nFunction\n.\n\n\nadjacency_matrix(g, dir=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse boolean adjacency matrix for a graph, indexed by \n[u, v]\n vertices. \ntrue\n values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:all\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nsource\n\n\n#\n\n\nErdos.incidence_matrix\n \u2014 \nFunction\n.\n\n\nincidence_matrix(g::ASimpleGraph, T::DataType=Int; oriented=false)\n\n\n\n\nReturns a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n.\n\n\nFor undirected graphs, both entries are \n1\n if \noriented=false\n, otherwise \n[v, i] -> -1\n and \n[u, i] -> 1\n if \nv < u\n.\n\n\nsource\n\n\n#\n\n\nErdos.laplacian_matrix\n \u2014 \nFunction\n.\n\n\nlaplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. \ndir\n has to be \n:in, :out\n or \n:all\n.\n\n\nsource\n\n\n#\n\n\nErdos.spectral_distance\n \u2014 \nMethod\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k])\n\n\n\n\nCompute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.\n\n\nFor further details, please refer to:\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\nsource\n\n\n#\n\n\nErdos.Nonbacktracking\n \u2014 \nType\n.\n\n\nNonbacktracking: a compact representation of the nonbacktracking operator\n\n\ng: the underlying graph\nedgeidmap: the association between oriented edges and index into the NBT matrix\n\n\n\n\nThe Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.\n\n\nGiven two oriented edges i->j and k->l in g, the non-backtraking matrix B is defined as\n\n\nB[i->j, k->l] = \u03b4(j,k)* (1 - \u03b4(i,l))\n\n\nThis type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.\n\n\nAdditionally the contract!(vertexspace, nbt, edgespace) method takes vectors represented in the domain of B and represents them in the domain of the adjacency matrix of g.\n\n\nsource\n\n\n#\n\n\nErdos.contract\n \u2014 \nMethod\n.\n\n\ncontract(nbt, edgespace) Integrates out the edges by summing over the edges incident to each vertex.\n\n\nsource\n\n\n#\n\n\nErdos.nonbacktracking_matrix\n \u2014 \nMethod\n.\n\n\nGiven two oriented edges i->j and k->l in g, the non-backtraking matrix B is defined as\n\n\nB[i->j, k->l] = \u03b4(j,k)* (1 - \u03b4(i,l))\n\n\nreturns a matrix B, and an edgemap storing the oriented edges' positions in B\n\n\nsource",
            "title": "Linear Algebra"
        },
        {
            "location": "/linalg/#linear-algebra",
            "text": "Erdos.jl  provides the following matrix operations on both directed and undirected graphs:  #  Erdos.adjacency_matrix  \u2014  Function .  adjacency_matrix(g, dir=:out, T::DataType=Int)  Returns a sparse boolean adjacency matrix for a graph, indexed by  [u, v]  vertices.  true  values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :all  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  source  #  Erdos.incidence_matrix  \u2014  Function .  incidence_matrix(g::ASimpleGraph, T::DataType=Int; oriented=false)  Returns a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 .  For undirected graphs, both entries are  1  if  oriented=false , otherwise  [v, i] -> -1  and  [u, i] -> 1  if  v < u .  source  #  Erdos.laplacian_matrix  \u2014  Function .  laplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)  Returns a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices.  dir  has to be  :in, :out  or  :all .  source  #  Erdos.spectral_distance  \u2014  Method .  spectral_distance(G\u2081, G\u2082 [, k])  Compute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.  For further details, please refer to:  JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations  source  #  Erdos.Nonbacktracking  \u2014  Type .  Nonbacktracking: a compact representation of the nonbacktracking operator  g: the underlying graph\nedgeidmap: the association between oriented edges and index into the NBT matrix  The Nonbacktracking operator can be used for community detection. This representation is compact in that it uses only ne(g) additional storage and provides an implicit representation of the matrix B_g defined below.  Given two oriented edges i->j and k->l in g, the non-backtraking matrix B is defined as  B[i->j, k->l] = \u03b4(j,k)* (1 - \u03b4(i,l))  This type is in the style of GraphMatrices.jl and supports the necessary operations for computed eigenvectors and conducting linear solves.  Additionally the contract!(vertexspace, nbt, edgespace) method takes vectors represented in the domain of B and represents them in the domain of the adjacency matrix of g.  source  #  Erdos.contract  \u2014  Method .  contract(nbt, edgespace) Integrates out the edges by summing over the edges incident to each vertex.  source  #  Erdos.nonbacktracking_matrix  \u2014  Method .  Given two oriented edges i->j and k->l in g, the non-backtraking matrix B is defined as  B[i->j, k->l] = \u03b4(j,k)* (1 - \u03b4(i,l))  returns a matrix B, and an edgemap storing the oriented edges' positions in B  source",
            "title": "Linear Algebra"
        },
        {
            "location": "/persistence/",
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nwritegraph\n function and read with the \nreadgraph\n function. Currently supported common graph formats are \nGraphML\n, \nGML\n, \nGexf\n, \nDOT\n, \nPajek .net\n, \ngraph-tool gt\n\n\n\n\nExamples\n\n\nwritegraph(\"mygraph.gml\", g) #format is inferred by the name\nwritegraph(\"mygraph.graphml\", g)\n\ng = readgraph(\"mygraph.dot\")\ng = readgraph(\"mygraph.net\")\n\n\n\n\n#\n\n\nErdos.readgraph\n \u2014 \nFunction\n.\n\n\nreadgraph(filename, G=Graph)\nreadgraph(filename, t, G=Graph; compressed=false)\n\n\n\n\nReads a graph from  \nfilename\n in the format \nt\n. Returns a graph of type \nG\n. Compressed files can eventually be read.\n\n\nSupported formats are \n:gml, :dot, :graphml, :gexf, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfilename\n.\n\n\nsource\n\n\n#\n\n\nErdos.writegraph\n \u2014 \nMethod\n.\n\n\nwritegraph(file, g)\nwritegraph(file, g, t; compress=false)\n\n\n\n\nSave a graph \ng\n to \nfile\n in the format \nt\n.\n\n\nEventually the resulting file can be compressed in the gzip format.\n\n\nCurrently supported formats are \n:gml, :graphml, :gexf, :dot, :net, :gt\n.\n\n\nIf no format is provided, it will be inferred from \nfile\n along with compression.\n\n\nsource",
            "title": "Reading / Writing Graphs"
        },
        {
            "location": "/persistence/#reading-and-writing-graphs",
            "text": "Graphs may be written to I/O streams and files using the  writegraph  function and read with the  readgraph  function. Currently supported common graph formats are  GraphML ,  GML ,  Gexf ,  DOT ,  Pajek .net ,  graph-tool gt",
            "title": "Reading and writing Graphs"
        },
        {
            "location": "/persistence/#examples",
            "text": "writegraph(\"mygraph.gml\", g) #format is inferred by the name\nwritegraph(\"mygraph.graphml\", g)\n\ng = readgraph(\"mygraph.dot\")\ng = readgraph(\"mygraph.net\")  #  Erdos.readgraph  \u2014  Function .  readgraph(filename, G=Graph)\nreadgraph(filename, t, G=Graph; compressed=false)  Reads a graph from   filename  in the format  t . Returns a graph of type  G . Compressed files can eventually be read.  Supported formats are  :gml, :dot, :graphml, :gexf, :net, :gt .  If no format is provided, it will be inferred from  filename .  source  #  Erdos.writegraph  \u2014  Method .  writegraph(file, g)\nwritegraph(file, g, t; compress=false)  Save a graph  g  to  file  in the format  t .  Eventually the resulting file can be compressed in the gzip format.  Currently supported formats are  :gml, :graphml, :gexf, :dot, :net, :gt .  If no format is provided, it will be inferred from  file  along with compression.  source",
            "title": "Examples"
        },
        {
            "location": "/generators/",
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nErdos.jl\n implements some common random graph generators:\n\n\n#\n\n\nErdos.barabasi_albert\n \u2014 \nFunction\n.\n\n\nbarabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)\n\n\n\n\nCreates a random graph of type \nG\n with \nn\n vertices according to \nBarab\u00e1si\u2013Albert model\n. It is grown by adding new vertices to an initial graph with \nn0\n vertices (\nn0=k\n if not specified). Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. The initial graph is empty by default.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nSee also \nbarabasi_albert!\n for growing a given graph.\n\n\nsource\n\n\n#\n\n\nErdos.barabasi_albert!\n \u2014 \nMethod\n.\n\n\nbarabasi_albert!(g, n::Int, k::Int; seed::Int = -1)\n\n\n\n\nGrows the graph \ng\n according to \nBarab\u00e1si\u2013Albert\n process into a graph with \nn\n vertices. At each step a new vertex is attached by preferential attachment to \nk\n different vertices already present in the graph.\n\n\nSee also \nbarabasi_albert\n.\n\n\nsource\n\n\n#\n\n\nErdos.erdos_renyi\n \u2014 \nFunction\n.\n\n\nerdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)\n\n\n\n\nCreates an \nErd\u0151s\u2013R\u00e9nyi\n random graph of type \nG\n with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n in the first method. In the second method \nm\n edges are randomly chosen insted.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n)\n\n\nNote also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using \nerdos_renyi(n, ne)\n or the  \nGraph(nv, ne)\n constructor, which randomly select \nne\n edges among all the potential edges.\n\n\nsource\n\n\n#\n\n\nErdos.random_configuration_model\n \u2014 \nFunction\n.\n\n\nrandom_configuration_model(n::Int, k::Vector{Int}; seed=-1, check_graphical=false)\n\n\n\n\nCreates a random undirected graph according to the \nconfiguraton model\n. It contains \nn\n vertices, the vertex \ni\n having degree \nk[i]\n.\n\n\nDefining \nc = mean(k)\n, it allocates an array of \nnc\n \nInt\ns, and takes approximately $nc^2$ time.\n\n\nIf \ncheck_graphical=true\n makes sure that \nk\n is a graphical sequence (see \nis_graphical\n).\n\n\nsource\n\n\n#\n\n\nErdos.random_regular_digraph\n \u2014 \nFunction\n.\n\n\nrandom_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)\n\n\n\n\nCreates a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n. The degree (in or out) can be specified using \ndir=:in\n or \ndir=:out\n. The default is \ndir=:out\n.\n\n\nFor directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nErdos.random_regular_graph\n \u2014 \nFunction\n.\n\n\nrandom_regular_graph(n::Int, k::Int; seed=-1)\n\n\n\n\nCreates a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nFor undirected graphs, allocates an array of \nnk\n \nInt\ns, and takes approximately $nk^2$ time. For $k > n/2$, generates a graph of degree \nn-k-1\n and returns its complement.\n\n\nsource\n\n\n#\n\n\nErdos.static_fitness_model\n \u2014 \nFunction\n.\n\n\nstatic_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)\n\n\n\n\nGenerates a random graph with \nlength(fitness)\n nodes and \nm\n edges, in which the probability of the existence of edge \n(i, j)\n is proportional to \nfitness[i]*fitness[j]\n. Time complexity is O(|V| + |E| log |E|).\n\n\nIn and out fitness have to be supplied for generating directed graphs.\n\n\nReference:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution\n\n\n\n\nin scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nsource\n\n\n#\n\n\nErdos.static_scale_free\n \u2014 \nFunction\n.\n\n\nfunction static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n. \nfinite_size_correction\n determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the \nstatic_fitness_model function\n. Time complexity is O(|V| + |E| log |E|).\n\n\nfunction static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random digraph\n\n\nReferences:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nErdos.stochastic_block_model\n \u2014 \nFunction\n.\n\n\nstochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)\n\n\n\n\nReturns a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$. \nn[a]\n : Number of vertices in block \na\n\n\nThe second form samples from a SBM with \nc[a,a]=cin\n, and \nc[a,b]=coff\n.\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nErdos.watts_strogatz\n \u2014 \nFunction\n.\n\n\nwatts_strogatz(n, k, \u03b2, G=Graph; seed=-1)\n\n\n\n\nCreates a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nsource\n\n\n\n\nStatic Graphs\n\n\nErdos.jl\n also implements a collection of classic graph generators:\n\n\n#\n\n\nErdos.BinaryTree\n \u2014 \nFunction\n.\n\n\nBinaryTree(levels, G=Graph)\n\n\n\n\nCreates a binary tree with k-levels vertices are numbered 1:2^levels-1\n\n\nsource\n\n\n#\n\n\nErdos.CliqueGraph\n \u2014 \nFunction\n.\n\n\nCliqueGraph(k, n, G=Graph)\n\n\n\n\nThis function generates a graph with \nn\n \nk\n-cliques connected circularly by \nn\n edges.\n\n\nsource\n\n\n#\n\n\nErdos.CompleteBipartiteGraph\n \u2014 \nFunction\n.\n\n\nCompleteBipartiteGraph(n1, n2, G = Graph)\n\n\n\n\nCreates a complete bipartite graph with \nn1+n2\n vertices. It has edges connecting each pair of vertices in the two sets.\n\n\nsource\n\n\n#\n\n\nErdos.CompleteDiGraph\n \u2014 \nFunction\n.\n\n\nCompleteDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a complete digraph with \nn\n vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).\n\n\nsource\n\n\n#\n\n\nErdos.CompleteGraph\n \u2014 \nFunction\n.\n\n\nCompleteGraph(n, G = Graph)\n\n\n\n\nCreates a complete graph of type \nG\n with \nn\n vertices. A complete graph has edges connecting each pair of vertices.\n\n\nsource\n\n\n#\n\n\nErdos.CycleDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a cycle digraph with \nn\n vertices. A cycle digraph is a closed path digraph.\n\n\nsource\n\n\n#\n\n\nErdos.CycleGraph\n \u2014 \nFunction\n.\n\n\nCycleGraph(n, G=Graph)\n\n\n\n\nCreates a cycle graph with \nn\n vertices. A cycle graph is a closed path graph.\n\n\nsource\n\n\n#\n\n\nErdos.DoubleBinaryTree\n \u2014 \nFunction\n.\n\n\nDoubleBinaryTree(levels, G=Graph)\n\n\n\n\nCreate a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.\n\n\nsource\n\n\n#\n\n\nErdos.Grid\n \u2014 \nFunction\n.\n\n\nGrid{T<:Integer}(dims::AbstractVector{T}; periodic=false)\n\n\n\n\nCreates a \nd\n-dimensional cubic lattice, with \nd=length(dims)\n and length  \ndims[i]\n in dimension \ni\n. If \nperiodic=true\n the resulting lattice will have periodic boundary condition in each dimension.\n\n\nsource\n\n\n#\n\n\nErdos.PathDiGraph\n \u2014 \nFunction\n.\n\n\nPathDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a path digraph with \nn\n vertices. A path graph connects each successive vertex by a single directed edge.\n\n\nsource\n\n\n#\n\n\nErdos.PathGraph\n \u2014 \nFunction\n.\n\n\nPathGraph(n, G = Graph)\n\n\n\n\nCreates a path graph with \nn\n vertices. A path graph connects each successive vertex by a single edge.\n\n\nsource\n\n\n#\n\n\nErdos.RoachGraph\n \u2014 \nFunction\n.\n\n\nThe Roach Graph from Guattery and Miller 1998\n\n\nsource\n\n\n#\n\n\nErdos.StarDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a star digraph with \nn\n vertices. A star digraph has a central vertex with directed edges to every other vertex.\n\n\nsource\n\n\n#\n\n\nErdos.StarGraph\n \u2014 \nFunction\n.\n\n\nStarGraph(n, G = Graph)\n\n\n\n\nCreates a star graph with \nn\n vertices. A star graph has a central vertex with edges to each other vertex.\n\n\nsource\n\n\n#\n\n\nErdos.WheelDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a wheel digraph with \nn\n vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n#\n\n\nErdos.WheelGraph\n \u2014 \nFunction\n.\n\n\nWheelGraph(n, G=Graph)\n\n\n\n\nCreates a wheel graph with \nn\n vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nErdos.digraph\n \u2014 \nFunction\n.\n\n\ndigraph(s::Symbol, G = DiGraph)\n\n\n\n\nCreates a notorious digraph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.digraph\n \u2014 \nFunction\n.\n\n\ndigraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a digraph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \u2014 \nFunction\n.\n\n\ngraph(s::Symbol, G = Graph)\n\n\n\n\nCreates a notorious graph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nErdos.graph\n \u2014 \nFunction\n.\n\n\ngraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a graph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nErdos.euclidean_graph\n \u2014 \nFunction\n.\n\n\neuclidean_graph(points::Matrix G=Graph; L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n builds an Euclidean graph of \nN\n vertices according to the following procedure.\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) < cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$.\n\n\nReturns a graph and Dict containing the distance on each edge.\n\n\neuclidean_graph(N, d, G=Graph; seed = -1, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGenerates \nN\n uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.\n\n\nReturns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.\n\n\nsource",
            "title": "Graph Generators"
        },
        {
            "location": "/generators/#generators",
            "text": "",
            "title": "Generators"
        },
        {
            "location": "/generators/#random-graphs",
            "text": "Erdos.jl  implements some common random graph generators:  #  Erdos.barabasi_albert  \u2014  Function .  barabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)  Creates a random graph of type  G  with  n  vertices according to  Barab\u00e1si\u2013Albert model . It is grown by adding new vertices to an initial graph with  n0  vertices ( n0=k  if not specified). Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. The initial graph is empty by default.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  See also  barabasi_albert!  for growing a given graph.  source  #  Erdos.barabasi_albert!  \u2014  Method .  barabasi_albert!(g, n::Int, k::Int; seed::Int = -1)  Grows the graph  g  according to  Barab\u00e1si\u2013Albert  process into a graph with  n  vertices. At each step a new vertex is attached by preferential attachment to  k  different vertices already present in the graph.  See also  barabasi_albert .  source  #  Erdos.erdos_renyi  \u2014  Function .  erdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)  Creates an  Erd\u0151s\u2013R\u00e9nyi  random graph of type  G  with  n  vertices. Edges are added between pairs of vertices with probability  p  in the first method. In the second method  m  edges are randomly chosen insted.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph )  Note also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using  erdos_renyi(n, ne)  or the   Graph(nv, ne)  constructor, which randomly select  ne  edges among all the potential edges.  source  #  Erdos.random_configuration_model  \u2014  Function .  random_configuration_model(n::Int, k::Vector{Int}; seed=-1, check_graphical=false)  Creates a random undirected graph according to the  configuraton model . It contains  n  vertices, the vertex  i  having degree  k[i] .  Defining  c = mean(k) , it allocates an array of  nc   Int s, and takes approximately $nc^2$ time.  If  check_graphical=true  makes sure that  k  is a graphical sequence (see  is_graphical ).  source  #  Erdos.random_regular_digraph  \u2014  Function .  random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)  Creates a random directed  regular graph  with  n  vertices, each with degree  k . The degree (in or out) can be specified using  dir=:in  or  dir=:out . The default is  dir=:out .  For directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  Erdos.random_regular_graph  \u2014  Function .  random_regular_graph(n::Int, k::Int; seed=-1)  Creates a random undirected  regular graph  with  n  vertices, each with degree  k .  For undirected graphs, allocates an array of  nk   Int s, and takes approximately $nk^2$ time. For $k > n/2$, generates a graph of degree  n-k-1  and returns its complement.  source  #  Erdos.static_fitness_model  \u2014  Function .  static_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)  Generates a random graph with  length(fitness)  nodes and  m  edges, in which the probability of the existence of edge  (i, j)  is proportional to  fitness[i]*fitness[j] . Time complexity is O(|V| + |E| log |E|).  In and out fitness have to be supplied for generating directed graphs.  Reference:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution   in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  source  #  Erdos.static_scale_free  \u2014  Function .  function static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)  Generates a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  finite_size_correction  determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the  static_fitness_model function . Time complexity is O(|V| + |E| log |E|).  function static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)  Generates a random digraph  References:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  Erdos.stochastic_block_model  \u2014  Function .  stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)  Returns a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$.  n[a]  : Number of vertices in block  a  The second form samples from a SBM with  c[a,a]=cin , and  c[a,b]=coff .  For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  Erdos.watts_strogatz  \u2014  Function .  watts_strogatz(n, k, \u03b2, G=Graph; seed=-1)  Creates a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 .  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  source",
            "title": "Random Graphs"
        },
        {
            "location": "/generators/#static-graphs",
            "text": "Erdos.jl  also implements a collection of classic graph generators:  #  Erdos.BinaryTree  \u2014  Function .  BinaryTree(levels, G=Graph)  Creates a binary tree with k-levels vertices are numbered 1:2^levels-1  source  #  Erdos.CliqueGraph  \u2014  Function .  CliqueGraph(k, n, G=Graph)  This function generates a graph with  n   k -cliques connected circularly by  n  edges.  source  #  Erdos.CompleteBipartiteGraph  \u2014  Function .  CompleteBipartiteGraph(n1, n2, G = Graph)  Creates a complete bipartite graph with  n1+n2  vertices. It has edges connecting each pair of vertices in the two sets.  source  #  Erdos.CompleteDiGraph  \u2014  Function .  CompleteDiGraph(n, G = DiGraph)  Creates a complete digraph with  n  vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).  source  #  Erdos.CompleteGraph  \u2014  Function .  CompleteGraph(n, G = Graph)  Creates a complete graph of type  G  with  n  vertices. A complete graph has edges connecting each pair of vertices.  source  #  Erdos.CycleDiGraph  \u2014  Function .  Creates a cycle digraph with  n  vertices. A cycle digraph is a closed path digraph.  source  #  Erdos.CycleGraph  \u2014  Function .  CycleGraph(n, G=Graph)  Creates a cycle graph with  n  vertices. A cycle graph is a closed path graph.  source  #  Erdos.DoubleBinaryTree  \u2014  Function .  DoubleBinaryTree(levels, G=Graph)  Create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.  source  #  Erdos.Grid  \u2014  Function .  Grid{T<:Integer}(dims::AbstractVector{T}; periodic=false)  Creates a  d -dimensional cubic lattice, with  d=length(dims)  and length   dims[i]  in dimension  i . If  periodic=true  the resulting lattice will have periodic boundary condition in each dimension.  source  #  Erdos.PathDiGraph  \u2014  Function .  PathDiGraph(n, G = DiGraph)  Creates a path digraph with  n  vertices. A path graph connects each successive vertex by a single directed edge.  source  #  Erdos.PathGraph  \u2014  Function .  PathGraph(n, G = Graph)  Creates a path graph with  n  vertices. A path graph connects each successive vertex by a single edge.  source  #  Erdos.RoachGraph  \u2014  Function .  The Roach Graph from Guattery and Miller 1998  source  #  Erdos.StarDiGraph  \u2014  Function .  Creates a star digraph with  n  vertices. A star digraph has a central vertex with directed edges to every other vertex.  source  #  Erdos.StarGraph  \u2014  Function .  StarGraph(n, G = Graph)  Creates a star graph with  n  vertices. A star graph has a central vertex with edges to each other vertex.  source  #  Erdos.WheelDiGraph  \u2014  Function .  Creates a wheel digraph with  n  vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.  source  #  Erdos.WheelGraph  \u2014  Function .  WheelGraph(n, G=Graph)  Creates a wheel graph with  n  vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.  source",
            "title": "Static Graphs"
        },
        {
            "location": "/generators/#small-graphs",
            "text": "Other classical graphs can be generated by the following function:  #  Erdos.digraph  \u2014  Function .  digraph(s::Symbol, G = DiGraph)  Creates a notorious digraph  s  of type  G . Admissible values for  s  are:     s  graph type      :truncatedtetrahedron  A skeleton of the  truncated tetrahedron digraph .     source  #  Erdos.digraph  \u2014  Function .  digraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a digraph with  n  vertices, type  G , and given  edgelist .  source  #  Erdos.graph  \u2014  Function .  graph(s::Symbol, G = Graph)  Creates a notorious graph  s  of type  G . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source  #  Erdos.graph  \u2014  Function .  graph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a graph with  n  vertices, type  G , and given  edgelist .  source",
            "title": "Small Graphs"
        },
        {
            "location": "/generators/#euclidean-graphs",
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  Erdos.euclidean_graph  \u2014  Function .  euclidean_graph(points::Matrix G=Graph; L=1., p=2., cutoff=-1., bc=:open)  Given the  d\u00d7N  matrix  points  builds an Euclidean graph of  N  vertices according to the following procedure.  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p) < cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$.  Returns a graph and Dict containing the distance on each edge.  euclidean_graph(N, d, G=Graph; seed = -1, L=1., p=2., cutoff=-1., bc=:open)  Generates  N  uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.  Returns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.  source",
            "title": "Euclidean Graphs"
        },
        {
            "location": "/centrality/",
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nErdos.jl\n include the following:\n\n\n\n\nErdos.betweenness_centrality\n\n\nErdos.closeness_centrality\n\n\nErdos.cores\n\n\nErdos.degree_centrality\n\n\nErdos.in_degree_centrality\n\n\nErdos.katz_centrality\n\n\nErdos.kcore\n\n\nErdos.out_degree_centrality\n\n\nErdos.pagerank\n\n\n\n\n#\n\n\nErdos.betweenness_centrality\n \u2014 \nMethod\n.\n\n\nbetweenness_centrality(g; normalize=true, endpoints=false, approx=-1)\n\n\n\n\nCalculates the \nbetweenness centrality\n of the vertices of graph \ng\n.\n\n\nBetweenness centrality for vertex \nv\n is defined as:\n\n\n$$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$\n\n\nwhere $\\sigma \n{st}} \\sigma\n$ is the total number of shortest paths from node \ns\n to node \nt\n and $\\sigma_{st}(v)$ is the number of those paths that pass through \nv\n.\n\n\nIf \nendpoints=true\n, endpoints are included in the shortest path count.\n\n\nIf \nnormalize=true\n, the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if \n((n-1)*(n-2))/2\n and for a directed graph, \n(n-1)*(n-2)\n where \nn\n is the number of vertices in the graph.\n\n\nIf  an integer argument \napprox > 0\n is given, returns an approximation of the betweenness centrality of each vertex of the graph involving \napprox\n randomly chosen vertices.\n\n\nReferences\n\n\n[1] Brandes 2001 & Brandes 2008\n\n\nsource\n\n\n#\n\n\nErdos.closeness_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ncloseness centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.in_degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.out_degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nErdos.katz_centrality\n \u2014 \nFunction\n.\n\n\nCalculates the \nKatz centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nErdos.pagerank\n \u2014 \nFunction\n.\n\n\npagerank(g::ADiGraph, \u03b1=0.85, n=100, \u03f5 = 1.0e-6)\n\n\n\n\nCalculates the \nPageRank\n of the graph \ng\n. Can optionally specify a different damping factor (\n\u03b1\n), number of iterations (\nn\n), and convergence threshold (\n\u03f5\n). If convergence is not reached within \nn\n iterations, an error will be returned.\n\n\nsource\n\n\n#\n\n\nErdos.cores\n \u2014 \nMethod\n.\n\n\ncores(g)\n\n\n\n\nReturns a vector \ndeg\n such that if \ndeg[v]=k\n then the vertex \nv\n belongs to the \nk\n-core of \ng\n and not to the \nk+1\n-core.\n\n\nSee also \nkcore\n.\n\n\nsource\n\n\n#\n\n\nErdos.kcore\n \u2014 \nMethod\n.\n\n\nkcore(g, k) -> (gnew, vmap)\n\n\n\n\nReturns the \nk\n-core  of \ng\n along with and vector that associates the new vertices to the old ones.\n\n\nSee also \ncores\n\n\nsource",
            "title": "Centrality Measures"
        },
        {
            "location": "/centrality/#centrality-measures",
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  Erdos.jl  include the following:   Erdos.betweenness_centrality  Erdos.closeness_centrality  Erdos.cores  Erdos.degree_centrality  Erdos.in_degree_centrality  Erdos.katz_centrality  Erdos.kcore  Erdos.out_degree_centrality  Erdos.pagerank   #  Erdos.betweenness_centrality  \u2014  Method .  betweenness_centrality(g; normalize=true, endpoints=false, approx=-1)  Calculates the  betweenness centrality  of the vertices of graph  g .  Betweenness centrality for vertex  v  is defined as:  $$\nbc(v) = \\frac{1}{\\mathcal{N}} \\sum_{s \\neq t \\neq v}\n        \\frac{\\sigma_{st}(v)}{\\sigma_{st}},\n$$  where $\\sigma  {st}} \\sigma $ is the total number of shortest paths from node  s  to node  t  and $\\sigma_{st}(v)$ is the number of those paths that pass through  v .  If  endpoints=true , endpoints are included in the shortest path count.  If  normalize=true , the betweenness values are normalized by the total number of possible distinct paths between all pairs in the graph. For an undirected graph, this number if  ((n-1)*(n-2))/2  and for a directed graph,  (n-1)*(n-2)  where  n  is the number of vertices in the graph.  If  an integer argument  approx > 0  is given, returns an approximation of the betweenness centrality of each vertex of the graph involving  approx  randomly chosen vertices.  References  [1] Brandes 2001 & Brandes 2008  source  #  Erdos.closeness_centrality  \u2014  Method .  Calculates the  closeness centrality  of the graph  g .  source  #  Erdos.degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.in_degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.out_degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  Erdos.katz_centrality  \u2014  Function .  Calculates the  Katz centrality  of the graph  g .  source  #  Erdos.pagerank  \u2014  Function .  pagerank(g::ADiGraph, \u03b1=0.85, n=100, \u03f5 = 1.0e-6)  Calculates the  PageRank  of the graph  g . Can optionally specify a different damping factor ( \u03b1 ), number of iterations ( n ), and convergence threshold ( \u03f5 ). If convergence is not reached within  n  iterations, an error will be returned.  source  #  Erdos.cores  \u2014  Method .  cores(g)  Returns a vector  deg  such that if  deg[v]=k  then the vertex  v  belongs to the  k -core of  g  and not to the  k+1 -core.  See also  kcore .  source  #  Erdos.kcore  \u2014  Method .  kcore(g, k) -> (gnew, vmap)  Returns the  k -core  of  g  along with and vector that associates the new vertices to the old ones.  See also  cores  source",
            "title": "Centrality Measures"
        },
        {
            "location": "/community/",
            "text": "Community Structures\n\n\nErdos.jl\n contains many algorithm to detect and analyze community structures in graphs.\n\n\n#\n\n\nErdos.global_clustering_coefficient\n \u2014 \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nComputes the \nglobal clustering coefficient\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering\n \u2014 \nFunction\n.\n\n\nlocal_clustering(g, vlist = vertices(g))\n\n\n\n\nReturns two vectors, respectively containing  the first and second result of \nlocal_clustering_coefficients(g, v)\n for each \nv\n in \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering\n \u2014 \nMethod\n.\n\n\nlocal_clustering(g, v)\n\n\n\n\nReturns a tuple \n(a,b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. It is related to the local clustering coefficient  by \nr=a/b\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering_coefficient\n \u2014 \nFunction\n.\n\n\nlocal_clustering_coefficient(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing  the \nlocal clustering coefficients\n for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.local_clustering_coefficient\n \u2014 \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\n\n\n\n\nComputes the \nlocal clustering coefficient\n for node \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.triangles\n \u2014 \nFunction\n.\n\n\ntriangles(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing the number of triangles for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nErdos.triangles\n \u2014 \nMethod\n.\n\n\ntriangles(g, v)\n\n\n\n\nReturns the number of triangles in the neighborhood for node \nv\n.\n\n\nsource\n\n\n#\n\n\nErdos.core_periphery_deg\n \u2014 \nMethod\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nA simple degree-based core-periphery detection algorithm (see \nLip\n). Returns the vertex assignments (1 for core and 2 for periphery).\n\n\nsource\n\n\n#\n\n\nErdos.modularity\n \u2014 \nMethod\n.\n\n\nmodularity(g, c)\n\n\n\n\nComputes Newman's modularity \nQ\n for graph \ng\n given the partitioning \nc\n.\n\n\nsource\n\n\n#\n\n\nErdos.maximal_cliques\n \u2014 \nMethod\n.\n\n\nFinds all maximal cliques of an undirected graph.\n\n\njulia> using Erdos\njulia> g = Graph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource\n\n\n#\n\n\nErdos.community_detection_bethe\n \u2014 \nFunction\n.\n\n\ncommunity_detection_bethe(g::AGraph, k=-1; kmax=15)\n\n\n\n\nCommunity detection using the spectral properties of the Bethe Hessian matrix associated to \ng\n (see \nSaade et al.\n). \nk\n is the number of community to detect. If omitted or if \nk<1\n the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by \nkmax\n. Returns a vector containing the vertex assignments.\n\n\nsource\n\n\n#\n\n\nErdos.community_detection_nback\n \u2014 \nMethod\n.\n\n\ncommunity_detection_nback(g::AGraph, k::Int)\n\n\n\n\nCommunity detection using the spectral properties of the non-backtracking matrix of \ng\n (see \nKrzakala et al.\n).\n\n\ng\n: imput Graph \nk\n: number of communities to detect\n\n\nreturn : array containing vertex assignments\n\n\nsource\n\n\n#\n\n\nErdos.label_propagation\n \u2014 \nMethod\n.\n\n\nCommunity detection using the label propagation algorithm (see \nRaghavan et al.\n). \ng\n: input Graph \nmaxiter\n: maximum number of iterations return : vertex assignments and the convergence history\n\n\nsource\n\n\n#\n\n\nErdos.nonbacktrack_embedding\n \u2014 \nMethod\n.\n\n\nSpectral embedding of the non-backtracking matrix of \ng\n (see \nKrzakala et al.\n).\n\n\ng\n: imput Graph \nk\n: number of dimensions in which to embed\n\n\nreturn : a matrix \u03d5 where \u03d5[:,i] are the coordinates for vertex i.\n\n\nNote does not explicitly construct the \nnonbacktracking_matrix\n. See \nNonbacktracking\n for details.\n\n\nsource",
            "title": "Community Structures"
        },
        {
            "location": "/community/#community-structures",
            "text": "Erdos.jl  contains many algorithm to detect and analyze community structures in graphs.  #  Erdos.global_clustering_coefficient  \u2014  Method .  global_clustering_coefficient(g)  Computes the  global clustering coefficient .  source  #  Erdos.local_clustering  \u2014  Function .  local_clustering(g, vlist = vertices(g))  Returns two vectors, respectively containing  the first and second result of  local_clustering_coefficients(g, v)  for each  v  in  vlist .  source  #  Erdos.local_clustering  \u2014  Method .  local_clustering(g, v)  Returns a tuple  (a,b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. It is related to the local clustering coefficient  by  r=a/b .  source  #  Erdos.local_clustering_coefficient  \u2014  Function .  local_clustering_coefficient(g, vlist = vertices(g))  Returns a vector containing  the  local clustering coefficients  for vertices  vlist .  source  #  Erdos.local_clustering_coefficient  \u2014  Method .  local_clustering_coefficient(g, v)  Computes the  local clustering coefficient  for node  v .  source  #  Erdos.triangles  \u2014  Function .  triangles(g, vlist = vertices(g))  Returns a vector containing the number of triangles for vertices  vlist .  source  #  Erdos.triangles  \u2014  Method .  triangles(g, v)  Returns the number of triangles in the neighborhood for node  v .  source  #  Erdos.core_periphery_deg  \u2014  Method .  core_periphery_deg(g)  A simple degree-based core-periphery detection algorithm (see  Lip ). Returns the vertex assignments (1 for core and 2 for periphery).  source  #  Erdos.modularity  \u2014  Method .  modularity(g, c)  Computes Newman's modularity  Q  for graph  g  given the partitioning  c .  source  #  Erdos.maximal_cliques  \u2014  Method .  Finds all maximal cliques of an undirected graph.  julia> using Erdos\njulia> g = Graph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source  #  Erdos.community_detection_bethe  \u2014  Function .  community_detection_bethe(g::AGraph, k=-1; kmax=15)  Community detection using the spectral properties of the Bethe Hessian matrix associated to  g  (see  Saade et al. ).  k  is the number of community to detect. If omitted or if  k<1  the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by  kmax . Returns a vector containing the vertex assignments.  source  #  Erdos.community_detection_nback  \u2014  Method .  community_detection_nback(g::AGraph, k::Int)  Community detection using the spectral properties of the non-backtracking matrix of  g  (see  Krzakala et al. ).  g : imput Graph  k : number of communities to detect  return : array containing vertex assignments  source  #  Erdos.label_propagation  \u2014  Method .  Community detection using the label propagation algorithm (see  Raghavan et al. ).  g : input Graph  maxiter : maximum number of iterations return : vertex assignments and the convergence history  source  #  Erdos.nonbacktrack_embedding  \u2014  Method .  Spectral embedding of the non-backtracking matrix of  g  (see  Krzakala et al. ).  g : imput Graph  k : number of dimensions in which to embed  return : a matrix \u03d5 where \u03d5[:,i] are the coordinates for vertex i.  Note does not explicitly construct the  nonbacktracking_matrix . See  Nonbacktracking  for details.  source",
            "title": "Community Structures"
        },
        {
            "location": "/flow/",
            "text": "Flow and Cut\n\n\nErdos.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nErdos.BoykovKolmogorovAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.DinicAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.EdmondsKarpAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.PushRelabelAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.maximum_flow\n \u2014 \nFunction\n.\n\n\nmaximum_flow{T<:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )\n\n\n\n\nGeneric maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.\n\n\nAll algorithms return a tuple with\n\n\n\n\nthe maximum flow\n\n\nthe flow matrix\n\n\nthe labelling associated to the minimum cut\n\n\n\n\nAvailable algorithms are \nDinicAlgorithm\n, \nEdmondsKarpAlgorithm\n, \nBoykovKolmogorovAlgorithm\n and \nPushRelabelAlgorithm\n.\n\n\nTime complexity is O(V\u00b2\u221aE) for the push relabel algorithm.\n\n\nUsage Example:\n\n\n\n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n\n\n\nsource\n\n\n#\n\n\nErdos.minimum_cut\n \u2014 \nMethod\n.\n\n\nminimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)\n\n\n\n\nFinds the \ns-t cut\n of minimal weight according to the \ncapacities\n matrix on the directed graph \ng\n. The solution is found through a maximal flow algorithm. See \nmaximum_flow\n for the optional arguments.\n\n\nReturns a triple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut.\n\n\nsource\n\n\n#\n\n\nErdos.ExtendedMultirouteFlowAlgorithm\n \u2014 \nType\n.\n\n\nForces the multiroute_flow function to use the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.KishimotoAlgorithm\n \u2014 \nType\n.\n\n\nForces the multiroute_flow function to use the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nErdos.multiroute_flow\n \u2014 \nFunction\n.\n\n\nThe generic multiroute_flow function will output three kinds of results:\n\n\n\n\nWhen the number of routes is 0 or non-specified, the set of breaking points of\n\n\n\n\nthe multiroute flow is returned.\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value k,\n\n\n\n\nonly the value of the k-route flow is returned\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph::ADiGraph                   # the input graph\n\n\nsource::Int                           # the source vertex\n\n\ntarget::Int                           # the target vertex\n\n\ncapacity_matrix::AbstractMatrix{T}  # edge flow capacities with T<:Real\n\n\nflow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm\n\n\nmrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm\n\n\nroutes::R<:Real                       # keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points\n\n\nroutes::R<:Real,                             # number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1<:Real)\n\n\nroutes::R<:Real                            # number of routes\n\n\nflow_graph::ADiGraph                        # the input graph\n\n\nsource::Int                                # the source vertex\n\n\ntarget::Int                                # the target vertex\n\n\ncapacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2<:Real)\n\n\nflow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.\n\n\nThe mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  max_flow section for options about flow_algorithm and capacity_matrix)\n\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)\n\n\n\n\n\nsource",
            "title": "Flow and Cut"
        },
        {
            "location": "/flow/#flow-and-cut",
            "text": "Erdos.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  Erdos.BoykovKolmogorovAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  Erdos.DinicAlgorithm  \u2014  Type .  Forces the maximum_flow function to use Dinic's algorithm.  source  #  Erdos.EdmondsKarpAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  Erdos.PushRelabelAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  Erdos.maximum_flow  \u2014  Function .  maximum_flow{T<:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )  Generic maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.  All algorithms return a tuple with   the maximum flow  the flow matrix  the labelling associated to the minimum cut   Available algorithms are  DinicAlgorithm ,  EdmondsKarpAlgorithm ,  BoykovKolmogorovAlgorithm  and  PushRelabelAlgorithm .  Time complexity is O(V\u00b2\u221aE) for the push relabel algorithm.  Usage Example:  \n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())  source  #  Erdos.minimum_cut  \u2014  Method .  minimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)  Finds the  s-t cut  of minimal weight according to the  capacities  matrix on the directed graph  g . The solution is found through a maximal flow algorithm. See  maximum_flow  for the optional arguments.  Returns a triple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut.  source  #  Erdos.ExtendedMultirouteFlowAlgorithm  \u2014  Type .  Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.  source  #  Erdos.KishimotoAlgorithm  \u2014  Type .  Forces the multiroute_flow function to use the Kishimoto algorithm.  source  #  Erdos.multiroute_flow  \u2014  Function .  The generic multiroute_flow function will output three kinds of results:   When the number of routes is 0 or non-specified, the set of breaking points of   the multiroute flow is returned.   When the input is limited to a set of breaking points and a route value k,   only the value of the k-route flow is returned   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph::ADiGraph                   # the input graph  source::Int                           # the source vertex  target::Int                           # the target vertex  capacity_matrix::AbstractMatrix{T}  # edge flow capacities with T<:Real  flow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm  mrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm  routes::R<:Real                       # keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points  routes::R<:Real,                             # number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1<:Real)  routes::R<:Real                            # number of routes  flow_graph::ADiGraph                        # the input graph  source::Int                                # the source vertex  target::Int                                # the target vertex  capacity_matrix::AbstractMatrix{T2}      # optional edge flow capacities (T2<:Real)  flow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.  The mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the  max_flow section for options about flow_algorithm and capacity_matrix)  \n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)  source",
            "title": "Flow and Cut"
        },
        {
            "location": "/matching/",
            "text": "Matching\n\n\nAlgorithms for the \noptimal matching problem\n.\n\n\n#\n\n\nErdos.minimum_weight_perfect_matching\n \u2014 \nFunction\n.\n\n\nminimum_weight_perfect_matching{T}(g, w::AEdgeMap{T},cutoff=typemax{T})\n\n\n\n\nGiven a graph \ng\n and an edgemap \nw\n containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly \nnv(g)/2\n edges. Edges in \ng\n not present in \nw\n will not be considered for the matching. The returned object is of type \nMatchingResult\n.\n\n\nTo reduce computational time, a \ncutoff\n argument can be given. Only edges with weight lower than \ncutoff\n will be considered for the matching.\n\n\nThis function relies on the BlossomV.jl package, a julia wrapper around Kolmogorov's BlossomV algorithm.\n\n\nsource",
            "title": "Matching"
        },
        {
            "location": "/matching/#matching",
            "text": "Algorithms for the  optimal matching problem .  #  Erdos.minimum_weight_perfect_matching  \u2014  Function .  minimum_weight_perfect_matching{T}(g, w::AEdgeMap{T},cutoff=typemax{T})  Given a graph  g  and an edgemap  w  containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly  nv(g)/2  edges. Edges in  g  not present in  w  will not be considered for the matching. The returned object is of type  MatchingResult .  To reduce computational time, a  cutoff  argument can be given. Only edges with weight lower than  cutoff  will be considered for the matching.  This function relies on the BlossomV.jl package, a julia wrapper around Kolmogorov's BlossomV algorithm.  source",
            "title": "Matching"
        },
        {
            "location": "/dismantling/",
            "text": "Matching\n\n\nAlgorithms for optimal network problems.\n\n\n#\n\n\nErdos.dismantle_ci\n \u2014 \nMethod\n.\n\n\ndismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)\n\n\n\n\nApplies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter \nl\n (tipically \nl=3,4\n). Removes a maximum of \nnrem\n vertices from \ng\n, trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.\n\n\nSet \nverbose\n to \ntrue\n for info printing in each iteration.\n\n\nReturns \n(gnew, vmap, remlist)\n, where \ngnew\n is the reduced graph, \nvmap\n is a vector mapping the vertices of \ng\n to the old ones (see also \nrem_vertices!\n) and \nremlist\n contains the removed vertices by removal order.\n\n\nFor more fine grained control see \ndismantle_ci_init\n and \ndismantle_ci_oneiter!\n.\n\n\nUsage\n\n\ng = Graph(100, 1000)\nl=3\nnrem=10\ngnew, vmap, remlist = dismantle_ci(g, l, nrem)\n\n# or equivalently\ngnew, heap, lneigs = dismantle_ci_init(g, l)\n\nfor it=1:nrem\n    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)\n    irem <= 0 && break\n    push!(remlist, irem)\n    println(\"Size Max Component: \", maximum(length, connected_components(g)))\nend\nvmap = rem_vertices!(gnew, remlist)\n\n\n\n\n[1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)\n\n\nsource\n\n\n#\n\n\nErdos.dismantle_ci_init\n \u2014 \nMethod\n.\n\n\ndismantle_ci_init(g, l)\n\n\n\n\nInitialization part of \ndismantle_ci\n algorithm. Returns \n(gnew, heap, lneigs)\n.\n\n\nsource\n\n\n#\n\n\nErdos.dismantle_ci_oneiter!\n \u2014 \nMethod\n.\n\n\ndismantle_ci_oneiter!(g, heap, lneigs, l)\n\n\n\n\nOne step of \ndismantle_ci\n algorithm. To be called after \ndismantle_ci_init\n Returns the cleaned vertex if any (see \nclean_vertex!\n), -1 otherwise.\n\n\nsource",
            "title": "Dismantling"
        },
        {
            "location": "/dismantling/#matching",
            "text": "Algorithms for optimal network problems.  #  Erdos.dismantle_ci  \u2014  Method .  dismantle_ci(g::AGraph, l::Integer, nrem; verbose=false)  Applies the Collective Influence (CI) heuristic of Ref. [1]  with distance parameter  l  (tipically  l=3,4 ). Removes a maximum of  nrem  vertices from  g , trying to minimize the size of the maximum connected component of the resulting graph. It stops earlier if the maximum CI goes to zero.  Set  verbose  to  true  for info printing in each iteration.  Returns  (gnew, vmap, remlist) , where  gnew  is the reduced graph,  vmap  is a vector mapping the vertices of  g  to the old ones (see also  rem_vertices! ) and  remlist  contains the removed vertices by removal order.  For more fine grained control see  dismantle_ci_init  and  dismantle_ci_oneiter! .  Usage  g = Graph(100, 1000)\nl=3\nnrem=10\ngnew, vmap, remlist = dismantle_ci(g, l, nrem)\n\n# or equivalently\ngnew, heap, lneigs = dismantle_ci_init(g, l)\n\nfor it=1:nrem\n    irem = dismantle_ci_oneiter!(gnew, heap, lneigs, l)\n    irem <= 0 && break\n    push!(remlist, irem)\n    println(\"Size Max Component: \", maximum(length, connected_components(g)))\nend\nvmap = rem_vertices!(gnew, remlist)  [1] Morone F., Makse H. Influence maximization in complex networks through optimal percolation. Nature (2015)  source  #  Erdos.dismantle_ci_init  \u2014  Method .  dismantle_ci_init(g, l)  Initialization part of  dismantle_ci  algorithm. Returns  (gnew, heap, lneigs) .  source  #  Erdos.dismantle_ci_oneiter!  \u2014  Method .  dismantle_ci_oneiter!(g, heap, lneigs, l)  One step of  dismantle_ci  algorithm. To be called after  dismantle_ci_init  Returns the cleaned vertex if any (see  clean_vertex! ), -1 otherwise.  source",
            "title": "Matching"
        },
        {
            "location": "/spanningtrees/",
            "text": "Spanning Trees\n\n\n#\n\n\nErdos.count_spanning_trees\n \u2014 \nMethod\n.\n\n\ncount_spanning_trees(g::AGraph)\n\n\n\n\nReturns the number of spanning trees of \ng\n, computed through \nKirchhoff's theorem\n. The return type is a float, since the number can be very large.\n\n\nsource\n\n\n#\n\n\nErdos.minimum_spanning_tree\n \u2014 \nFunction\n.\n\n\nminimum_spanning_tree{T<:Real}(\n    g, distmx::AbstractMatrix{T} = ConstEdgeMap(g,1)\n)\n\n\n\n\nPerforms \nKruskal's algorithm\n on a connected, undirected graph \ng\n, having adjacency matrix \ndistmx\n, and computes minimum spanning tree. Returns a \nVector{KruskalHeapEntry}\n, that contains the containing edges and its weights.\n\n\nsource",
            "title": "Spanning Trees"
        },
        {
            "location": "/spanningtrees/#spanning-trees",
            "text": "#  Erdos.count_spanning_trees  \u2014  Method .  count_spanning_trees(g::AGraph)  Returns the number of spanning trees of  g , computed through  Kirchhoff's theorem . The return type is a float, since the number can be very large.  source  #  Erdos.minimum_spanning_tree  \u2014  Function .  minimum_spanning_tree{T<:Real}(\n    g, distmx::AbstractMatrix{T} = ConstEdgeMap(g,1)\n)  Performs  Kruskal's algorithm  on a connected, undirected graph  g , having adjacency matrix  distmx , and computes minimum spanning tree. Returns a  Vector{KruskalHeapEntry} , that contains the containing edges and its weights.  source",
            "title": "Spanning Trees"
        }
    ]
}