{
    "docs": [
        {
            "location": "/",
            "text": "FatGraphs\n\n\n \n \n [//]: # (\n) [//]: # (\n)\n\n\nA graph library entirely written in Julia, derived from the beautiful library \nLightGraphs.jl\n.\n\n\n\n\nDocumentation\n\n\nFull documentation available at \nGitHub Pages\n. Documentation for methods is also available via the Julia REPL help system.\n\n\n\n\nInstallation\n\n\nInstallation is straightforward:\n\n\njulia> Pkg.clone(\"https://github.com/CarloLucibello/FatGraphs.jl\")\n\n\n\n\n\n\nUsage Examples\n\n\n(all examples apply equally to \nDiGraph\n unless otherwise noted):\n\n\ng = Graph() # empty undirected graph\n\ng = Graph(10) # a graph with 10 veritces and no edges\n@assert nv(g) == 10\n\ng = Graph(10, 30) # a graph with 10 vertices and 30 randomly placed edges\n@assert ne(g) == 30\n\nadd_edge!(g, 4, 5)\nadd_vertex!(g)\nrem_vertex!(g, 2)\nneighbors(g, 4)\n\n# iterate over the edges\nm = 0\nfor e in edges(g)\n    m += 1\nend\n@assert m == ne(g)\n\n# show distances between vertex 4 and all other vertices\ndijkstra_shortest_paths(g, 4).dists\n\n# as above, but with non-default edge distances\ndistmx = zeros(10,10)\ndistmx[4,5] = 2.5\ndistmx[5,4] = 2.5\ndijkstra_shortest_paths(g, 4, distmx=distmx).dists\n\n# graph I/O\ng = readgraph(\"mygraph.gml\", :gml)\nwritegraph(\"mygraph.gml\", g, :gml)\n\n\n\n\n\n\nCurrent functionality\n\n\n\n\ncore functions:\n vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)\n\n\ndistance within graphs:\n eccentricity, diameter, periphery, radius, center\n\n\ndistance between graphs:\n spectral_distance, edit_distance\n\n\nconnectivity:\n strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood\n\n\noperators:\n complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)\n\n\nshortest paths:\n Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*\n\n\nsmall graph generators:\n see \nsmallgraphs.jl\n for list\n\n\nrandom graph generators:\n Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model\n\n\ncentrality:\n betweenness, closeness, degree, pagerank, Katz\n\n\ntraversal operations:\n cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks\n\n\nflow operations:\n maximum flow, minimum s-t cut\n\n\nmatching:\n maximum weight matching on arbitrary graphs (through BlossomV algorithm)\n\n\nclique enumeration:\n maximal cliques\n\n\nlinear algebra / spectral graph theory:\n adjacency matrix (works as input to \nGraphLayout\n and \nMetis\n), Laplacian matrix, non-backtracking matrix\n\n\ncommunity:\n modularity, community detection, core-periphery, clustering coefficients\n\n\npersistence formats:\n proprietary compressed, \nGraphML\n, \nGML\n, \nGexf\n, \nDOT\n, \nPajek NET\n\n\nvisualization:\n integration with \nGraphLayout\n, \nTikzGraphs\n, \nGraphPlot\n, \nNetworkViz\n\n\n\n\n\n\nContributing and Reporting Bugs\n\n\nWe welcome contributions and bug reports! Please see \nCONTRIBUTING.md\n for guidance on development and bug reporting.",
            "title": "Getting Started"
        },
        {
            "location": "/#fatgraphs",
            "text": "[//]: # ( ) [//]: # ( )  A graph library entirely written in Julia, derived from the beautiful library  LightGraphs.jl .",
            "title": "FatGraphs"
        },
        {
            "location": "/#documentation",
            "text": "Full documentation available at  GitHub Pages . Documentation for methods is also available via the Julia REPL help system.",
            "title": "Documentation"
        },
        {
            "location": "/#installation",
            "text": "Installation is straightforward:  julia> Pkg.clone(\"https://github.com/CarloLucibello/FatGraphs.jl\")",
            "title": "Installation"
        },
        {
            "location": "/#usage-examples",
            "text": "(all examples apply equally to  DiGraph  unless otherwise noted):  g = Graph() # empty undirected graph\n\ng = Graph(10) # a graph with 10 veritces and no edges\n@assert nv(g) == 10\n\ng = Graph(10, 30) # a graph with 10 vertices and 30 randomly placed edges\n@assert ne(g) == 30\n\nadd_edge!(g, 4, 5)\nadd_vertex!(g)\nrem_vertex!(g, 2)\nneighbors(g, 4)\n\n# iterate over the edges\nm = 0\nfor e in edges(g)\n    m += 1\nend\n@assert m == ne(g)\n\n# show distances between vertex 4 and all other vertices\ndijkstra_shortest_paths(g, 4).dists\n\n# as above, but with non-default edge distances\ndistmx = zeros(10,10)\ndistmx[4,5] = 2.5\ndistmx[5,4] = 2.5\ndijkstra_shortest_paths(g, 4, distmx=distmx).dists\n\n# graph I/O\ng = readgraph(\"mygraph.gml\", :gml)\nwritegraph(\"mygraph.gml\", g, :gml)",
            "title": "Usage Examples"
        },
        {
            "location": "/#current-functionality",
            "text": "core functions:  vertices and edges addition and removal, degree (in/out/histogram), neighbors (in/out/all/common)  distance within graphs:  eccentricity, diameter, periphery, radius, center  distance between graphs:  spectral_distance, edit_distance  connectivity:  strongly- and weakly-connected components, bipartite checks, condensation, attracting components, neighborhood  operators:  complement, reverse, reverse!, union, join, intersect, difference, symmetric difference, blkdiag, induced subgraphs, products (cartesian/scalar)  shortest paths:  Dijkstra, Dijkstra with predecessors, Bellman-Ford, Floyd-Warshall, A*  small graph generators:  see  smallgraphs.jl  for list  random graph generators:  Erd\u0151s\u2013R\u00e9nyi, Watts-Strogatz, random regular, arbitrary degree sequence, stochastic block model  centrality:  betweenness, closeness, degree, pagerank, Katz  traversal operations:  cycle detection, BFS and DFS DAGs, BFS and DFS traversals with visitors, DFS topological sort, maximum adjacency / minimum cut, multiple random walks  flow operations:  maximum flow, minimum s-t cut  matching:  maximum weight matching on arbitrary graphs (through BlossomV algorithm)  clique enumeration:  maximal cliques  linear algebra / spectral graph theory:  adjacency matrix (works as input to  GraphLayout  and  Metis ), Laplacian matrix, non-backtracking matrix  community:  modularity, community detection, core-periphery, clustering coefficients  persistence formats:  proprietary compressed,  GraphML ,  GML ,  Gexf ,  DOT ,  Pajek NET  visualization:  integration with  GraphLayout ,  TikzGraphs ,  GraphPlot ,  NetworkViz",
            "title": "Current functionality"
        },
        {
            "location": "/#contributing-and-reporting-bugs",
            "text": "We welcome contributions and bug reports! Please see  CONTRIBUTING.md  for guidance on development and bug reporting.",
            "title": "Contributing and Reporting Bugs"
        },
        {
            "location": "/factory/",
            "text": "Graph Types\n\n\nFatGraphs.jl\n defines the following basic types and functionalities:\n\n\n#\n\n\nFatGraphs.DiGraph\n \u2014 \nType\n.\n\n\ntype DiGraph <: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{Int}}\n    badjlist::Vector{Vector{Int}}\nend\n\n\n\n\nA simple digraph type based on two adjacency lists (forward and backward).\n\n\nDiGraph(n=0)\n\n\n\n\nConstruct an empty DiGraph with \nn\n vertices.\n\n\nDiGraph{T<:Real}(adjmx::AbstractMatrix{T})\n\n\n\n\nConstruct a \nDiGraph\n from the adjacency matrix \nadjmx\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.Graph\n \u2014 \nType\n.\n\n\ntype Graph <: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{Int}}\nend\n\n\n\n\nA simple graph type based on an adjacency list.\n\n\nGraph(n=0)\n\n\n\n\nConstruct an empty Graph with \nn\n vertices.\n\n\nGraph(adjmx::AbstractMatrix)\n\n\n\n\nConstruct a \nGraph\n from the adjacency matrix \nadjmx\n.\n\n\nsource",
            "title": "Graph Types"
        },
        {
            "location": "/factory/#graph-types",
            "text": "FatGraphs.jl  defines the following basic types and functionalities:  #  FatGraphs.DiGraph  \u2014  Type .  type DiGraph <: ADiGraph\n    ne::Int\n    fadjlist::Vector{Vector{Int}}\n    badjlist::Vector{Vector{Int}}\nend  A simple digraph type based on two adjacency lists (forward and backward).  DiGraph(n=0)  Construct an empty DiGraph with  n  vertices.  DiGraph{T<:Real}(adjmx::AbstractMatrix{T})  Construct a  DiGraph  from the adjacency matrix  adjmx .  source  #  FatGraphs.Graph  \u2014  Type .  type Graph <: AGraph\n    ne::Int\n    fadjlist::Vector{Vector{Int}}\nend  A simple graph type based on an adjacency list.  Graph(n=0)  Construct an empty Graph with  n  vertices.  Graph(adjmx::AbstractMatrix)  Construct a  Graph  from the adjacency matrix  adjmx .  source",
            "title": "Graph Types"
        },
        {
            "location": "/core/",
            "text": "Basic Interface\n\n\nFatGraphs.jl\n defines the following basic types and functionalities:\n\n\n#\n\n\nFatGraphs.ADiGraph\n \u2014 \nType\n.\n\n\nAbstract directed graph type\n\n\nsource\n\n\n#\n\n\nFatGraphs.AGraph\n \u2014 \nType\n.\n\n\nAbstract (undirected) graph type\n\n\nGuarantees:     vertices are integers in 1:nv(g)\n\n\nFunctions to implement:     basic constructors (e.g. MyGraph(n), MyGraph())     nv(g)     ne(g)     out_neighbors(g, v)     in_neighbors(g, v) #digraph     edge(g, u, v)     add_edge!(g, u, v)     rem_edge!(g, u, v)     add_vertex!(g)     rem_vertex!(g, v)     graphtype(g)     digraphtype(g)\n\n\nReccomended Overrides:     in_adjlist(g) #digraph     out_adjlist(g)     has_edge(g, u, v)     ==(g, h)     out_edges(g, u)     in_edges(g, u) # digraph     rem_edge!(g, e)     graph(dg)     digraph(g)\n\n\nsource\n\n\n#\n\n\nFatGraphs.add_edge!\n \u2014 \nMethod\n.\n\n\nadd_edge!(g, e)\n\n\n\n\nAdd to \ng\n the edge \ne\n.\n\n\nadd_edge!(g, u, v)\n\n\n\n\nAdd to \ng\n an edge from \nu\n to \nv\n.\n\n\nWill return false if add fails (e.g., if vertices are not in the graph or the edge is already present) and true otherwise.\n\n\nsource\n\n\n#\n\n\nFatGraphs.add_vertex!\n \u2014 \nMethod\n.\n\n\nadd_vertex!(g)\n\n\n\n\nAdd a new vertex to the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.edge\n \u2014 \nMethod\n.\n\n\nedge(g, u, v)\n\n\n\n\nReturns an edge from 'u' to 'v'. The edge doesn't necessarily exists in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.in_neighbors\n \u2014 \nMethod\n.\n\n\nin_neighbors(g, v::Int)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an incoming edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nFatGraphs.ne\n \u2014 \nMethod\n.\n\n\nne(g)\n\n\n\n\nThe number of edges in \ng\n.\n\n\nTime Complexity: O(1)\n\n\nsource\n\n\n#\n\n\nFatGraphs.nv\n \u2014 \nMethod\n.\n\n\nnv(g)\n\n\n\n\nThe number of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.out_neighbors\n \u2014 \nMethod\n.\n\n\nout_neighbors(g::ASimpleGraph, v::Int)\n\n\n\n\nReturns an iterable to all neighbors connected to vertex \nv\n by an outgoing edge.\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nFatGraphs.rem_edge!\n \u2014 \nMethod\n.\n\n\nrem_edge!(g, e)\n\n\n\n\nRemove the edge \ne\n.\n\n\nrem_edge!(g, u, v)\n\n\n\n\nRemove the edge from \nu\n to \nv\n.\n\n\nReturns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.\n\n\nsource\n\n\n#\n\n\nFatGraphs.rem_vertex!\n \u2014 \nMethod\n.\n\n\nrem_vertex!(g, v)\n\n\n\n\nRemove the vertex \nv\n from graph \ng\n. It may change the index of other vertices (usually of the last one).\n\n\nsource\n\n\n#\n\n\nBase.reverse!\n \u2014 \nMethod\n.\n\n\nreverse!(g::DiGraph)\n\n\n\n\nIn-place reverse (modifies the original graph).\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \u2014 \nMethod\n.\n\n\nreverse(g::DiGraph)\n\n\n\n\nProduces a graph where all edges are reversed from the original.\n\n\nsource\n\n\n#\n\n\nFatGraphs.add_vertices!\n \u2014 \nMethod\n.\n\n\nadd_vertices!(g, n)\n\n\n\n\nAdd \nn\n new vertices to the graph \ng\n. Returns the final number of vertices.\n\n\nsource\n\n\n#\n\n\nFatGraphs.adjlist\n \u2014 \nMethod\n.\n\n\nadjlist(g)\n\n\n\n\nReturns the adjacency list of a graph (a vector of vector of ints). It is equivalent to  \nout_adjlist(g)\n.\n\n\nNOTE: For most graph types it returns a reference, not a copy, therefore the returned object should not be modified.\n\n\nsource\n\n\n#\n\n\nFatGraphs.all_edges\n \u2014 \nMethod\n.\n\n\nall_edges(g, v)\n\n\n\n\nIterates over all in and out edges of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.all_neighbors\n \u2014 \nMethod\n.\n\n\nall_neighbors(g, v)\n\n\n\n\nIterates over all distinct in/out neighbors of vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.clean_vertex!\n \u2014 \nMethod\n.\n\n\nclean_vertex!(g, v)\n\n\n\n\nRemove all incident edges on vertex \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.degree\n \u2014 \nMethod\n.\n\n\ndegree(g, v)\n\n\n\n\nReturn the number of edges  from the vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.density\n \u2014 \nMethod\n.\n\n\ndensity(g)\n\n\n\n\nDensity is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.\n\n\nsource\n\n\n#\n\n\nFatGraphs.edges\n \u2014 \nMethod\n.\n\n\nedges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nIt is equivalent to \nout_edges\n.\n\n\nFor digraphs, use \nall_edges\n to iterate over both in and out edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.has_edge\n \u2014 \nMethod\n.\n\n\nhas_edge(g, e)\nhas_edge(g, u, v)\n\n\n\n\nReturns true if the graph \ng\n has an edge \ne\n (from \nu\n to \nv\n).\n\n\nsource\n\n\n#\n\n\nFatGraphs.has_vertex\n \u2014 \nMethod\n.\n\n\nhas_vertex(g, v)\n\n\n\n\nReturn true if \nv\n is a vertex of \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.in_adjlist\n \u2014 \nMethod\n.\n\n\nin_adjlist(g)\n\n\n\n\nReturns the backward adjacency list of a graph. For each vertex the vector of neighbors though incoming edges.\n\n\nin_adjlist(g) == [collect(in_neighbors(i)) for i=1:nv(g)]\n\n\n\n\nIt is the same as \nadjlist\n and \nout_adjlist\n for undirected graphs.\n\n\nNOTE: returns a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nFatGraphs.in_degree\n \u2014 \nMethod\n.\n\n\nin_degree(g, v)\n\n\n\n\nReturns the number of edges which start at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.in_edges\n \u2014 \nMethod\n.\n\n\nin_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n going to vertex \nv\n. \nv == dst(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_directed\n \u2014 \nMethod\n.\n\n\nis_directed(g)\n\n\n\n\nCheck if \ng\n a graph with directed edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.neighbors\n \u2014 \nMethod\n.\n\n\nneighbors(g, v)\n\n\n\n\nReturns a list of all neighbors from vertex \nv\n in \ng\n.\n\n\nFor directed graph, this is equivalent to \nout_neighbors\n(g, v).\n\n\nNOTE: it may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nFatGraphs.out_adjlist\n \u2014 \nMethod\n.\n\n\nout_adjlist(g)\n\n\n\n\nReturns the forward adjacency list of a graph, i.e. a vector of vectors containing for each vertex the neighbors trhough outgoing edges.\n\n\nout_adjlist(g) == [collect(out_neighbors(i)) for i=1:nv(g)]\n\n\n\n\nThe adjacency list is be pre-calculated for most graph types. It is the same as \nadjlist\n and \nin_adjlist\n for undirected graphs and the same as \nadjlist\n for directed ones.\n\n\nNOTE: It may return a reference, not a copy. Do not modify result.\n\n\nsource\n\n\n#\n\n\nFatGraphs.out_degree\n \u2014 \nMethod\n.\n\n\nout_degree(g, v)\n\n\n\n\nReturns the number of edges which end at vertex \nv\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.out_edges\n \u2014 \nMethod\n.\n\n\nout_edges(g, v)\n\n\n\n\nReturns an iterator to the edges in \ng\n coming from vertex \nv\n. \nv == src(e)\n for each returned edge \ne\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.vertices\n \u2014 \nMethod\n.\n\n\nvertices(g)\n\n\n\n\nReturns an iterator to the vertices of a graph (i.e. 1:nv(g))\n\n\nsource\n\n\n#\n\n\nFatGraphs.Edge\n \u2014 \nType\n.\n\n\nimmutable Edge\n    src::Int\n    dst::Int\nend\n\n\n\n\nA type representing an edge between two vertices of a graph.\n\n\nsource\n\n\n#\n\n\nBase.reverse\n \u2014 \nMethod\n.\n\n\nreverse(e::Edge)\n\n\n\n\nSwap \ne.src\n and \ne.dst\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.dst\n \u2014 \nMethod\n.\n\n\ndst(e::Edge)\n\n\n\n\nReturns the destination of an edge.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_ordered\n \u2014 \nMethod\n.\n\n\nis_ordered(e::Edge)\n\n\n\n\nReturns  \nsrc(e) <= dst(e)\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.src\n \u2014 \nMethod\n.\n\n\nsrc(e::Edge)\n\n\n\n\nReturns the source of an edge.\n\n\nsource\n\n\n#\n\n\nFatGraphs.edges\n \u2014 \nFunction\n.\n\n\nedges(g)\nedges(g, vertices)\n\n\n\n\nReturns an iterator to the edges of a graph \ng\n. The returned iterator is invalidated by changes to \ng\n.\n\n\nIf the optional argument \nvertices\n is given,  the returned iterator runs only over the edges between vertex in \nvertices\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.common_inneighbors\n \u2014 \nMethod\n.\n\n\ncommon_inneighbors(g, u, v)\n\n\n\n\nReturns the inneighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.common_neighbors\n \u2014 \nMethod\n.\n\n\ncommon_neighbors(g, u, v)\n\n\n\n\nReturns the neighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.common_outneighbors\n \u2014 \nMethod\n.\n\n\ncommon_outneighbors(g, u, v)\n\n\n\n\nReturns the outneighbors common to vertices \nu\n and \nv\n in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.degree_histogram\n \u2014 \nMethod\n.\n\n\ndegree_histogram(g)\n\n\n\n\nReturns a \nStatsBase.Histogram\n of the degrees of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.has_self_loops\n \u2014 \nMethod\n.\n\n\nhas_self_loops(g)\n\n\n\n\nReturns true if \ng\n has any self loops.\n\n\nsource\n\n\n#\n\n\nFatGraphs.isgraphical\n \u2014 \nMethod\n.\n\n\nisgraphical(degs::Vector{Int})\n\n\n\n\nCheck whether the degree sequence \ndegs\n is graphical, according to \nErd\u00f6s-Gallai condition\n.\n\n\nTime complexity: O(length(degs)^2)\n\n\nsource\n\n\n#\n\n\nFatGraphs.num_self_loops\n \u2014 \nMethod\n.\n\n\nnum_self_loops(g)\n\n\n\n\nReturns the number of self loops in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u0394\n \u2014 \nMethod\n.\n\n\nReturn the maximum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u0394in\n \u2014 \nMethod\n.\n\n\nReturn the minimum \nin_degree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u0394out\n \u2014 \nMethod\n.\n\n\nReturn the maximum \nout_degree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u03b4\n \u2014 \nMethod\n.\n\n\nReturn the minimum \ndegree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u03b4in\n \u2014 \nMethod\n.\n\n\nReturn the maximum \nin_degree\n of vertices in \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.\u03b4out\n \u2014 \nMethod\n.\n\n\nReturn the minimum \nout_degree\n of vertices in \ng\n.\n\n\nsource",
            "title": "Basic Interface"
        },
        {
            "location": "/core/#basic-interface",
            "text": "FatGraphs.jl  defines the following basic types and functionalities:  #  FatGraphs.ADiGraph  \u2014  Type .  Abstract directed graph type  source  #  FatGraphs.AGraph  \u2014  Type .  Abstract (undirected) graph type  Guarantees:     vertices are integers in 1:nv(g)  Functions to implement:     basic constructors (e.g. MyGraph(n), MyGraph())     nv(g)     ne(g)     out_neighbors(g, v)     in_neighbors(g, v) #digraph     edge(g, u, v)     add_edge!(g, u, v)     rem_edge!(g, u, v)     add_vertex!(g)     rem_vertex!(g, v)     graphtype(g)     digraphtype(g)  Reccomended Overrides:     in_adjlist(g) #digraph     out_adjlist(g)     has_edge(g, u, v)     ==(g, h)     out_edges(g, u)     in_edges(g, u) # digraph     rem_edge!(g, e)     graph(dg)     digraph(g)  source  #  FatGraphs.add_edge!  \u2014  Method .  add_edge!(g, e)  Add to  g  the edge  e .  add_edge!(g, u, v)  Add to  g  an edge from  u  to  v .  Will return false if add fails (e.g., if vertices are not in the graph or the edge is already present) and true otherwise.  source  #  FatGraphs.add_vertex!  \u2014  Method .  add_vertex!(g)  Add a new vertex to the graph  g .  source  #  FatGraphs.edge  \u2014  Method .  edge(g, u, v)  Returns an edge from 'u' to 'v'. The edge doesn't necessarily exists in  g .  source  #  FatGraphs.in_neighbors  \u2014  Method .  in_neighbors(g, v::Int)  Returns an iterable to all neighbors connected to vertex  v  by an incoming edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  FatGraphs.ne  \u2014  Method .  ne(g)  The number of edges in  g .  Time Complexity: O(1)  source  #  FatGraphs.nv  \u2014  Method .  nv(g)  The number of vertices in  g .  source  #  FatGraphs.out_neighbors  \u2014  Method .  out_neighbors(g::ASimpleGraph, v::Int)  Returns an iterable to all neighbors connected to vertex  v  by an outgoing edge.  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  FatGraphs.rem_edge!  \u2014  Method .  rem_edge!(g, e)  Remove the edge  e .  rem_edge!(g, u, v)  Remove the edge from  u  to  v .  Returns false if edge removal fails (e.g., if the edge does not exist) and true otherwise.  source  #  FatGraphs.rem_vertex!  \u2014  Method .  rem_vertex!(g, v)  Remove the vertex  v  from graph  g . It may change the index of other vertices (usually of the last one).  source  #  Base.reverse!  \u2014  Method .  reverse!(g::DiGraph)  In-place reverse (modifies the original graph).  source  #  Base.reverse  \u2014  Method .  reverse(g::DiGraph)  Produces a graph where all edges are reversed from the original.  source  #  FatGraphs.add_vertices!  \u2014  Method .  add_vertices!(g, n)  Add  n  new vertices to the graph  g . Returns the final number of vertices.  source  #  FatGraphs.adjlist  \u2014  Method .  adjlist(g)  Returns the adjacency list of a graph (a vector of vector of ints). It is equivalent to   out_adjlist(g) .  NOTE: For most graph types it returns a reference, not a copy, therefore the returned object should not be modified.  source  #  FatGraphs.all_edges  \u2014  Method .  all_edges(g, v)  Iterates over all in and out edges of vertex  v  in  g .  source  #  FatGraphs.all_neighbors  \u2014  Method .  all_neighbors(g, v)  Iterates over all distinct in/out neighbors of vertex  v  in  g .  source  #  FatGraphs.clean_vertex!  \u2014  Method .  clean_vertex!(g, v)  Remove all incident edges on vertex  v  in  g .  source  #  FatGraphs.degree  \u2014  Method .  degree(g, v)  Return the number of edges  from the vertex  v .  source  #  FatGraphs.density  \u2014  Method .  density(g)  Density is defined as the ratio of the number of actual edges to the number of possible edges. This is $|v| |v-1|$ for directed graphs and $(|v| |v-1|) / 2$ for undirected graphs.  source  #  FatGraphs.edges  \u2014  Method .  edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  It is equivalent to  out_edges .  For digraphs, use  all_edges  to iterate over both in and out edges.  source  #  FatGraphs.has_edge  \u2014  Method .  has_edge(g, e)\nhas_edge(g, u, v)  Returns true if the graph  g  has an edge  e  (from  u  to  v ).  source  #  FatGraphs.has_vertex  \u2014  Method .  has_vertex(g, v)  Return true if  v  is a vertex of  g .  source  #  FatGraphs.in_adjlist  \u2014  Method .  in_adjlist(g)  Returns the backward adjacency list of a graph. For each vertex the vector of neighbors though incoming edges.  in_adjlist(g) == [collect(in_neighbors(i)) for i=1:nv(g)]  It is the same as  adjlist  and  out_adjlist  for undirected graphs.  NOTE: returns a reference, not a copy. Do not modify result.  source  #  FatGraphs.in_degree  \u2014  Method .  in_degree(g, v)  Returns the number of edges which start at vertex  v .  source  #  FatGraphs.in_edges  \u2014  Method .  in_edges(g, v)  Returns an iterator to the edges in  g  going to vertex  v .  v == dst(e)  for each returned edge  e .  source  #  FatGraphs.is_directed  \u2014  Method .  is_directed(g)  Check if  g  a graph with directed edges.  source  #  FatGraphs.neighbors  \u2014  Method .  neighbors(g, v)  Returns a list of all neighbors from vertex  v  in  g .  For directed graph, this is equivalent to  out_neighbors (g, v).  NOTE: it may return a reference, not a copy. Do not modify result.  source  #  FatGraphs.out_adjlist  \u2014  Method .  out_adjlist(g)  Returns the forward adjacency list of a graph, i.e. a vector of vectors containing for each vertex the neighbors trhough outgoing edges.  out_adjlist(g) == [collect(out_neighbors(i)) for i=1:nv(g)]  The adjacency list is be pre-calculated for most graph types. It is the same as  adjlist  and  in_adjlist  for undirected graphs and the same as  adjlist  for directed ones.  NOTE: It may return a reference, not a copy. Do not modify result.  source  #  FatGraphs.out_degree  \u2014  Method .  out_degree(g, v)  Returns the number of edges which end at vertex  v .  source  #  FatGraphs.out_edges  \u2014  Method .  out_edges(g, v)  Returns an iterator to the edges in  g  coming from vertex  v .  v == src(e)  for each returned edge  e .  source  #  FatGraphs.vertices  \u2014  Method .  vertices(g)  Returns an iterator to the vertices of a graph (i.e. 1:nv(g))  source  #  FatGraphs.Edge  \u2014  Type .  immutable Edge\n    src::Int\n    dst::Int\nend  A type representing an edge between two vertices of a graph.  source  #  Base.reverse  \u2014  Method .  reverse(e::Edge)  Swap  e.src  and  e.dst .  source  #  FatGraphs.dst  \u2014  Method .  dst(e::Edge)  Returns the destination of an edge.  source  #  FatGraphs.is_ordered  \u2014  Method .  is_ordered(e::Edge)  Returns   src(e) <= dst(e) .  source  #  FatGraphs.src  \u2014  Method .  src(e::Edge)  Returns the source of an edge.  source  #  FatGraphs.edges  \u2014  Function .  edges(g)\nedges(g, vertices)  Returns an iterator to the edges of a graph  g . The returned iterator is invalidated by changes to  g .  If the optional argument  vertices  is given,  the returned iterator runs only over the edges between vertex in  vertices .  source  #  FatGraphs.common_inneighbors  \u2014  Method .  common_inneighbors(g, u, v)  Returns the inneighbors common to vertices  u  and  v  in  g .  source  #  FatGraphs.common_neighbors  \u2014  Method .  common_neighbors(g, u, v)  Returns the neighbors common to vertices  u  and  v  in  g .  source  #  FatGraphs.common_outneighbors  \u2014  Method .  common_outneighbors(g, u, v)  Returns the outneighbors common to vertices  u  and  v  in  g .  source  #  FatGraphs.degree_histogram  \u2014  Method .  degree_histogram(g)  Returns a  StatsBase.Histogram  of the degrees of vertices in  g .  source  #  FatGraphs.has_self_loops  \u2014  Method .  has_self_loops(g)  Returns true if  g  has any self loops.  source  #  FatGraphs.isgraphical  \u2014  Method .  isgraphical(degs::Vector{Int})  Check whether the degree sequence  degs  is graphical, according to  Erd\u00f6s-Gallai condition .  Time complexity: O(length(degs)^2)  source  #  FatGraphs.num_self_loops  \u2014  Method .  num_self_loops(g)  Returns the number of self loops in  g .  source  #  FatGraphs.\u0394  \u2014  Method .  Return the maximum  degree  of vertices in  g .  source  #  FatGraphs.\u0394in  \u2014  Method .  Return the minimum  in_degree  of vertices in  g .  source  #  FatGraphs.\u0394out  \u2014  Method .  Return the maximum  out_degree  of vertices in  g .  source  #  FatGraphs.\u03b4  \u2014  Method .  Return the minimum  degree  of vertices in  g .  source  #  FatGraphs.\u03b4in  \u2014  Method .  Return the maximum  in_degree  of vertices in  g .  source  #  FatGraphs.\u03b4out  \u2014  Method .  Return the minimum  out_degree  of vertices in  g .  source",
            "title": "Basic Interface"
        },
        {
            "location": "/operators/",
            "text": "Operators\n\n\nFatGraphs.jl\n implements the following graph operators:\n\n\n\n\nBase.SparseArrays.blkdiag\n\n\nBase.intersect\n\n\nBase.join\n\n\nBase.union\n\n\nFatGraphs.cartesian_product\n\n\nFatGraphs.complement\n\n\nFatGraphs.complete\n\n\nFatGraphs.complete!\n\n\nFatGraphs.crosspath\n\n\nFatGraphs.difference\n\n\nFatGraphs.egonet\n\n\nFatGraphs.subgraph\n\n\nFatGraphs.symmetric_difference\n\n\nFatGraphs.tensor_product\n\n\n\n\n#\n\n\nBase.SparseArrays.blkdiag\n \u2014 \nMethod\n.\n\n\nblkdiag(g, h)\n\n\n\n\nProduces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.\n\n\nPut simply, the vertices and edges from graph \nh\n are appended to graph \ng\n.\n\n\nsource\n\n\n#\n\n\nBase.intersect\n \u2014 \nMethod\n.\n\n\nintersect(g, h)\n\n\n\n\nProduces a graph with edges that are only in both graph \ng\n and graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nBase.join\n \u2014 \nMethod\n.\n\n\njoin(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n using \nblkdiag\n and then adds all the edges between  the vertices in \ng\n and those in \nh\n.\n\n\nsource\n\n\n#\n\n\nBase.union\n \u2014 \nMethod\n.\n\n\nunion(g, h)\n\n\n\n\nMerges graphs \ng\n and \nh\n by taking the set union of all vertices and edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.cartesian_product\n \u2014 \nMethod\n.\n\n\ncartesian_product(g, h)\n\n\n\n\nReturns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource\n\n\n#\n\n\nFatGraphs.complement\n \u2014 \nMethod\n.\n\n\ncomplement(g)\n\n\n\n\nProduces the \ngraph complement\n of a graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.complete!\n \u2014 \nMethod\n.\n\n\ncomplete(g::ADiGraph)\n\n\n\n\nReturns a digraph containing both the edges \n(u,v)\n of \ng\n and their reverse \n(v,u)\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.complete\n \u2014 \nMethod\n.\n\n\ncomplete(g::ADiGraph)\n\n\n\n\nReturns a digraph containing both the edges \n(u,v)\n of \ng\n and their reverse \n(v,u)\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.crosspath\n \u2014 \nMethod\n.\n\n\ncrosspath(len::Integer, g::AGraph)\n\n\n\n\nReplicate \nlen\n times \nh\n and connect each vertex with its copies in a path\n\n\nsource\n\n\n#\n\n\nFatGraphs.difference\n \u2014 \nMethod\n.\n\n\ndifference(g, h)\n\n\n\n\nProduces a graph with edges in graph \ng\n that are not in graph \nh\n.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nFatGraphs.egonet\n \u2014 \nMethod\n.\n\n\negonet(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns the subgraph of \ng\n induced by the neighbors of \nv\n up to distance \nd\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered. This is equivalent to \nsubgraph\n(g, neighborhood(g, v, d, dir=dir))[1].\n\n\nsource\n\n\n#\n\n\nFatGraphs.subgraph\n \u2014 \nMethod\n.\n\n\nsubgraph(g, vlist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the vertices in  \nvlist\n.\n\n\nThe returned graph has \nlength(vlist)\n vertices, with the new vertex \ni\n corresponding to the vertex of the original graph in the \ni\n-th position of \nvlist\n.\n\n\nReturns  also a vector \nvmap\n mapping the new vertices to the old ones: the  vertex \ni\n in the subgraph corresponds to the vertex \nvmap[i]\n in \ng\n.\n\n\nsubgraph(g, elist)\n\n\n\n\nReturns the subgraph of \ng\n induced by the edges in \nelist\n, along with the associated vector \nvmap\n mapping new vertices to the old ones.\n\n\nUsage Examples:\n\n\ng = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.symmetric_difference\n \u2014 \nMethod\n.\n\n\nsymmetric_difference(g, h)\n\n\n\n\nProduces a graph with edges from graph \ng\n that do not exist in graph \nh\n, and vice versa.\n\n\nNote that this function may produce a graph with 0-degree vertices.\n\n\nsource\n\n\n#\n\n\nFatGraphs.tensor_product\n \u2014 \nMethod\n.\n\n\ntensor_product(g, h)\n\n\n\n\nReturns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of \ng\n and \nh\n\n\nsource",
            "title": "Operators"
        },
        {
            "location": "/operators/#operators",
            "text": "FatGraphs.jl  implements the following graph operators:   Base.SparseArrays.blkdiag  Base.intersect  Base.join  Base.union  FatGraphs.cartesian_product  FatGraphs.complement  FatGraphs.complete  FatGraphs.complete!  FatGraphs.crosspath  FatGraphs.difference  FatGraphs.egonet  FatGraphs.subgraph  FatGraphs.symmetric_difference  FatGraphs.tensor_product   #  Base.SparseArrays.blkdiag  \u2014  Method .  blkdiag(g, h)  Produces a graph with $|V(g)| + |V(h)|$ vertices and $|E(g)| + |E(h)|$ edges.  Put simply, the vertices and edges from graph  h  are appended to graph  g .  source  #  Base.intersect  \u2014  Method .  intersect(g, h)  Produces a graph with edges that are only in both graph  g  and graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  Base.join  \u2014  Method .  join(g, h)  Merges graphs  g  and  h  using  blkdiag  and then adds all the edges between  the vertices in  g  and those in  h .  source  #  Base.union  \u2014  Method .  union(g, h)  Merges graphs  g  and  h  by taking the set union of all vertices and edges.  source  #  FatGraphs.cartesian_product  \u2014  Method .  cartesian_product(g, h)  Returns the (cartesian product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source  #  FatGraphs.complement  \u2014  Method .  complement(g)  Produces the  graph complement  of a graph.  source  #  FatGraphs.complete!  \u2014  Method .  complete(g::ADiGraph)  Returns a digraph containing both the edges  (u,v)  of  g  and their reverse  (v,u) .  source  #  FatGraphs.complete  \u2014  Method .  complete(g::ADiGraph)  Returns a digraph containing both the edges  (u,v)  of  g  and their reverse  (v,u) .  source  #  FatGraphs.crosspath  \u2014  Method .  crosspath(len::Integer, g::AGraph)  Replicate  len  times  h  and connect each vertex with its copies in a path  source  #  FatGraphs.difference  \u2014  Method .  difference(g, h)  Produces a graph with edges in graph  g  that are not in graph  h .  Note that this function may produce a graph with 0-degree vertices.  source  #  FatGraphs.egonet  \u2014  Method .  egonet(g, v::Int, d::Int; dir=:out)  Returns the subgraph of  g  induced by the neighbors of  v  up to distance  d . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered. This is equivalent to  subgraph (g, neighborhood(g, v, d, dir=dir))[1].  source  #  FatGraphs.subgraph  \u2014  Method .  subgraph(g, vlist)  Returns the subgraph of  g  induced by the vertices in   vlist .  The returned graph has  length(vlist)  vertices, with the new vertex  i  corresponding to the vertex of the original graph in the  i -th position of  vlist .  Returns  also a vector  vmap  mapping the new vertices to the old ones: the  vertex  i  in the subgraph corresponds to the vertex  vmap[i]  in  g .  subgraph(g, elist)  Returns the subgraph of  g  induced by the edges in  elist , along with the associated vector  vmap  mapping new vertices to the old ones.  Usage Examples:  g = CompleteGraph(10)\nsg, vmap = subgraph(g, 5:8)\n@assert g[5:8] == sg\n@assert nv(sg) == 4\n@assert ne(sg) == 6\n@assert vm[4] == 8\n\nsg, vmap = subgraph(g, [2,8,3,4])\n@asssert sg == g[[2,8,3,4]]\n\nelist = [Edge(1,2), Edge(3,4), Edge(4,8)]\nsg, vmap = subgraph(g, elist)\n@asssert sg == g[elist]  source  #  FatGraphs.symmetric_difference  \u2014  Method .  symmetric_difference(g, h)  Produces a graph with edges from graph  g  that do not exist in graph  h , and vice versa.  Note that this function may produce a graph with 0-degree vertices.  source  #  FatGraphs.tensor_product  \u2014  Method .  tensor_product(g, h)  Returns the (tensor product)[https://en.wikipedia.org/wiki/Tensor_product_of_graphs] of  g  and  h  source",
            "title": "Operators"
        },
        {
            "location": "/traversals/",
            "text": "Path and Traversal\n\n\nFatGraphs.jl\n provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.\n\n\nEdge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by \n[src,dst]\n vertices. That is, \ndistmx[2,4] = 2.5\n assigns the distance \n2.5\n to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs \ndistmx[4,2]\n has to be set.\n\n\nAny graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,\n\n\n\n\ndistance values for undefined edges will be ignored, and\n\n\nany unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.\n\n\nany zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.\n\n\n\n\n\n\nGraph Traversal\n\n\nGraph traversal\n refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:\n\n\n\n\nBreadthFirst\n,\n\n\nDepthFirst\n, and\n\n\nMaximumAdjacency\n.\n\n\n\n\n\n\n\n#\n\n\nFatGraphs.BreadthFirst\n \u2014 \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor < 0     => examined but not closed\n\n\ncolor > 0     => examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor == 1     => examined\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.bfs_tree\n \u2014 \nMethod\n.\n\n\nProvides a breadth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nThis function is a high level wrapper around bfs_tree!, use that function for more performance.\n\n\nsource\n\n\n#\n\n\nFatGraphs.bipartite_map\n \u2014 \nMethod\n.\n\n\nbipartite_map(g)\n\n\n\n\nIf the graph is bipartite returns a vector \nc\n  of size \nnv(g)\n containing the assignment of each vertex to one of the two sets (\nc[i] == 1\n or \nc[i]==2\n). If \ng\n is not bipartite returns an empty vector.\n\n\nsource\n\n\n#\n\n\nFatGraphs.gdistances!\n \u2014 \nMethod\n.\n\n\ngdistances!(g, source, dists) -> dists\n\n\n\n\nFills \ndists\n with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. \ndists\n can be either a vector or a dictionary.\n\n\nsource\n\n\n#\n\n\nFatGraphs.gdistances\n \u2014 \nMethod\n.\n\n\ngdistances(g, source) -> dists\n\n\n\n\nReturns a vector filled with the geodesic distances of vertices in  \ng\n from vertex/vertices \nsource\n. For vertices in disconnected components the default distance is -1.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_bipartite\n \u2014 \nMethod\n.\n\n\nis_bipartite(g)\nis_bipartite(g, v)\n\n\n\n\nWill return \ntrue\n if graph \ng\n is \nbipartite\n. If a node \nv\n is specified, only the connected component to which it belongs is considered.\n\n\nsource\n\n\n#\n\n\nFatGraphs.DepthFirst\n \u2014 \nType\n.\n\n\nConventions in Breadth First Search and Depth First Search\n VertexColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor < 0     => examined but not closed\n\n\ncolor > 0     => examined and closed\n\n\n\n\nEdgeColorMap :\n\n\n\n\ncolor == 0    => unseen\n\n\ncolor == 1     => examined\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.dfs_tree\n \u2014 \nMethod\n.\n\n\ndfs_tree(g, s::Int)\n\n\n\n\nProvides a depth-first traversal of the graph \ng\n starting with source vertex \ns\n, and returns a directed acyclic graph of vertices in the order they were discovered.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_cyclic\n \u2014 \nMethod\n.\n\n\nis_cyclic(g)\n\n\n\n\nTests whether a graph contains a cycle through depth-first search. It returns \ntrue\n when it finds a cycle, otherwise \nfalse\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.maximum_adjacency_visit\n \u2014 \nMethod\n.\n\n\nReturns the vertices in \ng\n traversed by maximum adjacency search. An optional \ndistmx\n matrix may be specified; if omitted, edge distances are assumed to be 1. If \nlog\n (default \nfalse\n) is \ntrue\n, visitor events will be printed to \nio\n, which defaults to \nSTDOUT\n; otherwise, no event information will be displayed.\n\n\nsource\n\n\n#\n\n\nFatGraphs.minimum_cut\n \u2014 \nMethod\n.\n\n\nminimum_cut(g, dist_matrix=DefaultDistance())\n\n\n\n\nFinds the \ncut\n of minimum total weight.\n\n\nReturns a tuple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut. An optional \ndist_matrix\n matrix maybe specified; if omitted, edge distances are assumed to be 1.\n\n\nsource\n\n\n\n\nRandom walks\n\n\nFatGraphs\n includes uniform random walks and self avoiding walks:\n\n\n#\n\n\nFatGraphs.non_backtracking_randomwalk\n \u2014 \nMethod\n.\n\n\nnon_backtracking_randomwalk(g, s, niter)\n\n\n\n\nPerforms a non-backtracking random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nFatGraphs.randomwalk\n \u2014 \nMethod\n.\n\n\nrandomwalk(g, s, niter)\n\n\n\n\nPerforms a random walk on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n#\n\n\nFatGraphs.self_avoiding_randomwalk\n \u2014 \nMethod\n.\n\n\nself_avoiding_randomwalk(g, s, niter)\n\n\n\n\nPerforms a \nself-avoiding walk\n on graph \ng\n starting at vertex \ns\n and continuing for a maximum of \nniter\n steps. Returns a vector of vertices visited in order.\n\n\nsource\n\n\n\n\nConnectivity / Bipartiteness\n\n\nGraph connectivity\n functions are defined on both undirected and directed graphs:\n\n\n#\n\n\nFatGraphs.attracting_components\n \u2014 \nMethod\n.\n\n\nattracting_components(g::ADiGraph)\n\n\n\n\nReturns a vector of vectors of integers representing lists of attracting components in \ng\n. The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.condensation\n \u2014 \nMethod\n.\n\n\ncondensation(g::ADiGraph)\n\n\n\n\nReturns the condensation graph associated with \ng\n. The condensation \nh\n of a graph \ng\n is the directed graph where every node in \nh\n represents a strongly connected component in \ng\n, and the presence of an edge between between nodes in \nh\n indicates that there is at least one edge between the associated strongly connected components in \ng\n. The node numbering in \nh\n corresponds to the ordering of the components output from \nstrongly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.connected_components\n \u2014 \nMethod\n.\n\n\nconnected_components(g::AGraph)\n\n\n\n\nReturns the \nconnected components\n of \ng\n as a vector of components, each represented by a vector of vertices belonging to the component.\n\n\nSee also \nweakly_connected_components\n and \nstrongly_connected_components\n for directed graphs.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_connected\n \u2014 \nMethod\n.\n\n\nis_connected(g)\n\n\n\n\nReturns \ntrue\n if \ng\n is connected. For DiGraphs, this is equivalent to a test of weak connectivity.\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_strongly_connected\n \u2014 \nMethod\n.\n\n\nis_strongly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if \ng\n is strongly connected.\n\n\nSee also \nstrongly_connected_components\n\n\nsource\n\n\n#\n\n\nFatGraphs.is_weakly_connected\n \u2014 \nMethod\n.\n\n\nis_weakly_connected(g::ADiGraph)\n\n\n\n\nReturns \ntrue\n if the undirected graph \ng\n is weakly connected.\n\n\nSee also \nweakly_connected_components\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.neighborhood\n \u2014 \nMethod\n.\n\n\nneighborhood(g, v::Int, d::Int; dir=:out)\n\n\n\n\nReturns a vector of the vertices in \ng\n at distance less or equal to \nd\n from \nv\n. If \ng\n is a \nDiGraph\n the \ndir\n optional argument specifies the edge direction the edge direction with respect to \nv\n (i.e. \n:in\n or \n:out\n) to be considered.\n\n\nsource\n\n\n#\n\n\nFatGraphs.period\n \u2014 \nMethod\n.\n\n\nperiod(g::ADiGraph)\n\n\n\n\nComputes the common period for all nodes in a strongly connected graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.strongly_connected_components\n \u2014 \nMethod\n.\n\n\nstrongly_connected_components(g::ADiGraph)\n\n\n\n\nComputes the strongly connected components of a directed graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.weakly_connected_components\n \u2014 \nMethod\n.\n\n\nweakly_connected_components(g::ADiGraph)\n\n\n\n\nReturns the weakly connected components of undirected graph \ng\n. It is equivalent to the connected components of the corresponding undirected graph, i.e. \nconnected_components(graph(g))\n.\n\n\nsource",
            "title": "Traversals"
        },
        {
            "location": "/traversals/#path-and-traversal",
            "text": "FatGraphs.jl  provides several traversal and shortest-path algorithms, along with various utility functions. Where appropriate, edge distances may be passed in as a matrix of real number values.  Edge distances for most traversals may be passed in as a sparse or dense matrix of  values, indexed by  [src,dst]  vertices. That is,  distmx[2,4] = 2.5  assigns the distance  2.5  to the (directed) edge connecting vertex 2 and vertex 4. Note that also for undirected graphs  distmx[4,2]  has to be set.  Any graph traversal  will traverse an edge only if it is present in the graph. When a distance matrix is passed in,   distance values for undefined edges will be ignored, and  any unassigned values (in sparse distance matrices), for edges that are present in the graph, will be assumed to take the default value of 1.0.  any zero values (in sparse/dense distance matrices), for edges that are present in the graph, will instead have an implicit edge cost of 1.0.",
            "title": "Path and Traversal"
        },
        {
            "location": "/traversals/#graph-traversal",
            "text": "Graph traversal  refers to a process that traverses vertices of a graph following certain order (starting from user-input sources). This package implements three traversal schemes:   BreadthFirst ,  DepthFirst , and  MaximumAdjacency .    #  FatGraphs.BreadthFirst  \u2014  Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    => unseen  color < 0     => examined but not closed  color > 0     => examined and closed   EdgeColorMap :   color == 0    => unseen  color == 1     => examined   source  #  FatGraphs.bfs_tree  \u2014  Method .  Provides a breadth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  This function is a high level wrapper around bfs_tree!, use that function for more performance.  source  #  FatGraphs.bipartite_map  \u2014  Method .  bipartite_map(g)  If the graph is bipartite returns a vector  c   of size  nv(g)  containing the assignment of each vertex to one of the two sets ( c[i] == 1  or  c[i]==2 ). If  g  is not bipartite returns an empty vector.  source  #  FatGraphs.gdistances!  \u2014  Method .  gdistances!(g, source, dists) -> dists  Fills  dists  with the geodesic distances of vertices in   g  from vertex/vertices  source .  dists  can be either a vector or a dictionary.  source  #  FatGraphs.gdistances  \u2014  Method .  gdistances(g, source) -> dists  Returns a vector filled with the geodesic distances of vertices in   g  from vertex/vertices  source . For vertices in disconnected components the default distance is -1.  source  #  FatGraphs.is_bipartite  \u2014  Method .  is_bipartite(g)\nis_bipartite(g, v)  Will return  true  if graph  g  is  bipartite . If a node  v  is specified, only the connected component to which it belongs is considered.  source  #  FatGraphs.DepthFirst  \u2014  Type .  Conventions in Breadth First Search and Depth First Search  VertexColorMap :   color == 0    => unseen  color < 0     => examined but not closed  color > 0     => examined and closed   EdgeColorMap :   color == 0    => unseen  color == 1     => examined   source  #  FatGraphs.dfs_tree  \u2014  Method .  dfs_tree(g, s::Int)  Provides a depth-first traversal of the graph  g  starting with source vertex  s , and returns a directed acyclic graph of vertices in the order they were discovered.  source  #  FatGraphs.is_cyclic  \u2014  Method .  is_cyclic(g)  Tests whether a graph contains a cycle through depth-first search. It returns  true  when it finds a cycle, otherwise  false .  source  #  FatGraphs.maximum_adjacency_visit  \u2014  Method .  Returns the vertices in  g  traversed by maximum adjacency search. An optional  distmx  matrix may be specified; if omitted, edge distances are assumed to be 1. If  log  (default  false ) is  true , visitor events will be printed to  io , which defaults to  STDOUT ; otherwise, no event information will be displayed.  source  #  FatGraphs.minimum_cut  \u2014  Method .  minimum_cut(g, dist_matrix=DefaultDistance())  Finds the  cut  of minimum total weight.  Returns a tuple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut. An optional  dist_matrix  matrix maybe specified; if omitted, edge distances are assumed to be 1.  source",
            "title": "Graph Traversal"
        },
        {
            "location": "/traversals/#random-walks",
            "text": "FatGraphs  includes uniform random walks and self avoiding walks:  #  FatGraphs.non_backtracking_randomwalk  \u2014  Method .  non_backtracking_randomwalk(g, s, niter)  Performs a non-backtracking random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  FatGraphs.randomwalk  \u2014  Method .  randomwalk(g, s, niter)  Performs a random walk on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source  #  FatGraphs.self_avoiding_randomwalk  \u2014  Method .  self_avoiding_randomwalk(g, s, niter)  Performs a  self-avoiding walk  on graph  g  starting at vertex  s  and continuing for a maximum of  niter  steps. Returns a vector of vertices visited in order.  source",
            "title": "Random walks"
        },
        {
            "location": "/traversals/#connectivity-bipartiteness",
            "text": "Graph connectivity  functions are defined on both undirected and directed graphs:  #  FatGraphs.attracting_components  \u2014  Method .  attracting_components(g::ADiGraph)  Returns a vector of vectors of integers representing lists of attracting components in  g . The attracting components are a subset of the strongly connected components in which the components do not have any leaving edges.  source  #  FatGraphs.condensation  \u2014  Method .  condensation(g::ADiGraph)  Returns the condensation graph associated with  g . The condensation  h  of a graph  g  is the directed graph where every node in  h  represents a strongly connected component in  g , and the presence of an edge between between nodes in  h  indicates that there is at least one edge between the associated strongly connected components in  g . The node numbering in  h  corresponds to the ordering of the components output from  strongly_connected_components .  source  #  FatGraphs.connected_components  \u2014  Method .  connected_components(g::AGraph)  Returns the  connected components  of  g  as a vector of components, each represented by a vector of vertices belonging to the component.  See also  weakly_connected_components  and  strongly_connected_components  for directed graphs.  source  #  FatGraphs.is_connected  \u2014  Method .  is_connected(g)  Returns  true  if  g  is connected. For DiGraphs, this is equivalent to a test of weak connectivity.  source  #  FatGraphs.is_strongly_connected  \u2014  Method .  is_strongly_connected(g::ADiGraph)  Returns  true  if  g  is strongly connected.  See also  strongly_connected_components  source  #  FatGraphs.is_weakly_connected  \u2014  Method .  is_weakly_connected(g::ADiGraph)  Returns  true  if the undirected graph  g  is weakly connected.  See also  weakly_connected_components .  source  #  FatGraphs.neighborhood  \u2014  Method .  neighborhood(g, v::Int, d::Int; dir=:out)  Returns a vector of the vertices in  g  at distance less or equal to  d  from  v . If  g  is a  DiGraph  the  dir  optional argument specifies the edge direction the edge direction with respect to  v  (i.e.  :in  or  :out ) to be considered.  source  #  FatGraphs.period  \u2014  Method .  period(g::ADiGraph)  Computes the common period for all nodes in a strongly connected graph.  source  #  FatGraphs.strongly_connected_components  \u2014  Method .  strongly_connected_components(g::ADiGraph)  Computes the strongly connected components of a directed graph.  source  #  FatGraphs.weakly_connected_components  \u2014  Method .  weakly_connected_components(g::ADiGraph)  Returns the weakly connected components of undirected graph  g . It is equivalent to the connected components of the corresponding undirected graph, i.e.  connected_components(graph(g)) .  source",
            "title": "Connectivity / Bipartiteness"
        },
        {
            "location": "/distance/",
            "text": "Distance\n\n\nFatGraphs.jl\n includes the following distance measurements:\n\n\n#\n\n\nFatGraphs.center\n \u2014 \nMethod\n.\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).\n\n\nsource\n\n\n#\n\n\nFatGraphs.diameter\n \u2014 \nMethod\n.\n\n\nReturns the maximum eccentricity of the graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.eccentricity\n \u2014 \nFunction\n.\n\n\nCalculates the eccentricity[ies] of a vertex \nv\n, vertex vector \nvs\n, or the entire graph. An optional matrix of edge distances may be supplied.\n\n\nThe eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.\n\n\nBecause this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.\n\n\nThe output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.\n\n\nNote: the eccentricity vector returned by \neccentricity()\n may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.\n\n\nsource\n\n\n#\n\n\nFatGraphs.periphery\n \u2014 \nMethod\n.\n\n\nReturns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).\n\n\nsource\n\n\n#\n\n\nFatGraphs.radius\n \u2014 \nMethod\n.\n\n\nReturns the minimum eccentricity of the graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.BoundedMinkowskiCost\n \u2014 \nMethod\n.\n\n\nSimilar to MinkowskiCost, but ensures costs smaller than 2\u03c4.\n\n\nsource\n\n\n#\n\n\nFatGraphs.MinkowskiCost\n \u2014 \nMethod\n.\n\n\nFor labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.\n\n\nsource\n\n\n#\n\n\nFatGraphs.edit_distance\n \u2014 \nMethod\n.\n\n\nComputes the edit distance between graphs G\u2081 and G\u2082.\n\n\nReturns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:\n\n\n\n\n(0,v): insertion of vertex v \u2208 G\u2082\n\n\n(u,0): deletion of vertex u \u2208 G\u2081\n\n\n(u>0,v>0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082\n\n\n\n\nBy default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:\n\n\nedit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))\n\n\n\n\nA custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory.\n\n\nPerformance tips:\n\n\n\n\nGiven two graphs |G\u2081| < |G\u2082|, \nedit_distance(G\u2081, G\u2082)\n is faster to\n\n\n\n\ncompute than \nedit_distance(G\u2082, G\u2081)\n. Consider swapping the arguments if involved costs are ``symmetric''.\n\n\n\n\nThe use of simple Minkowski costs can improve performance considerably.\n\n\nExploit vertex attributes when designing operation costs.\n\n\n\n\nFor further details, please refer to:\n\n\nRIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)\n\n\nAuthor: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)\n\n\nsource",
            "title": "Distance"
        },
        {
            "location": "/distance/#distance",
            "text": "FatGraphs.jl  includes the following distance measurements:  #  FatGraphs.center  \u2014  Method .  Returns the set of all vertices whose eccentricity is equal to the graph's radius (that is, the set of vertices with the smallest eccentricity).  source  #  FatGraphs.diameter  \u2014  Method .  Returns the maximum eccentricity of the graph.  source  #  FatGraphs.eccentricity  \u2014  Function .  Calculates the eccentricity[ies] of a vertex  v , vertex vector  vs , or the entire graph. An optional matrix of edge distances may be supplied.  The eccentricity of a vertex is the maximum shortest-path distance between it and all other vertices in the graph.  Because this function must calculate shortest paths for all vertices supplied in the argument list, it may take a long time.  The output is either a single float (when a single vertex is provided) or a vector of floats corresponding to the vertex vector. If no vertex vector is provided, the vector returned corresponds to each vertex in the graph.  Note: the eccentricity vector returned by  eccentricity()  may be used as input for the rest of the distance measures below. If an eccentricity vector is provided, it will be used. Otherwise, an eccentricity vector will be calculated for each call to the function. It may therefore be more efficient to calculate, store, and pass the eccentricities if multiple distance measures are desired.  source  #  FatGraphs.periphery  \u2014  Method .  Returns the set of all vertices whose eccentricity is equal to the graph's diameter (that is, the set of vertices with the largest eccentricity).  source  #  FatGraphs.radius  \u2014  Method .  Returns the minimum eccentricity of the graph.  source  #  FatGraphs.BoundedMinkowskiCost  \u2014  Method .  Similar to MinkowskiCost, but ensures costs smaller than 2\u03c4.  source  #  FatGraphs.MinkowskiCost  \u2014  Method .  For labels \u03bc\u2081 on the vertices of graph G\u2081 and labels \u03bc\u2082 on the vertices of graph G\u2082, compute the p-norm cost of substituting vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082.  source  #  FatGraphs.edit_distance  \u2014  Method .  Computes the edit distance between graphs G\u2081 and G\u2082.  Returns the minimum edit cost and edit path to transform graph G\u2081 into graph G\u2082. An edit path consists of a sequence of pairs of vertices (u,v) \u2208 [0,|G\u2081|] \u00d7 [0,|G\u2082|] representing vertex operations:   (0,v): insertion of vertex v \u2208 G\u2082  (u,0): deletion of vertex u \u2208 G\u2081  (u>0,v>0): substitution of vertex u \u2208 G\u2081 by vertex v \u2208 G\u2082   By default, the algorithm uses constant operation costs. The user can provide classical Minkowski costs computed from vertex labels \u03bc\u2081 (for G\u2081) and \u03bc\u2082 (for G\u2082) in order to further guide the search, for example:  edit_distance(G\u2081, G\u2082, subst_cost=MinkowskiCost(\u03bc\u2081, \u03bc\u2082))  A custom heuristic can be provided to the A* search in case the default heuristic is not satisfactory.  Performance tips:   Given two graphs |G\u2081| < |G\u2082|,  edit_distance(G\u2081, G\u2082)  is faster to   compute than  edit_distance(G\u2082, G\u2081) . Consider swapping the arguments if involved costs are ``symmetric''.   The use of simple Minkowski costs can improve performance considerably.  Exploit vertex attributes when designing operation costs.   For further details, please refer to:  RIESEN, K., 2015. Structural Pattern Recognition with Graph Edit Distance: Approximation Algorithms and Applications. (Chapter 2)  Author: J\u00falio Hoffimann Mendes (juliohm@stanford.edu)  source",
            "title": "Distance"
        },
        {
            "location": "/shortestpaths/",
            "text": "Shortest-Path Algorithms\n\n\n\n\nGeneral properties of shortest path algorithms\n\n\n\n\nThe distance from a vertex to itself is always \n0\n.\n\n\nThe distance between two vertices with no connecting edge is always \nInf\n.\n\n\n\n\n\n\nShortest-Path Algorithms\n\n\n#\n\n\nFatGraphs.a_star\n \u2014 \nFunction\n.\n\n\na_star(g, s, t, distmx=DefaultDistance(), heuristic = n->0)\n\n\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied.\n\n\nsource\n\n\n#\n\n\nFatGraphs.bellman_ford_shortest_paths\n \u2014 \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, sources, distmx=DefaultDistance())\n\n\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths of all vertices of a \ng\n from a source vertex \ns\n (or a set of source vertices \nsources\n). Returns a \nBellmanFordState\n with relevant traversal information (see below).\n\n\nsource\n\n\n#\n\n\nFatGraphs.enumerate_paths\n \u2014 \nMethod\n.\n\n\nenumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.dijkstra_shortest_paths\n \u2014 \nFunction\n.\n\n\ndijkstra_shortest_paths(g, s, distmx=DefaultDistance(); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=DefaultDistance(); allpaths=false)\n\n\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n (or a vector \nsources\n)  and all other veritces. Returns a \nDijkstraState\n that contains various traversal information.\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nFatGraphs.floyd_warshall_shortest_paths\n \u2014 \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance())\n\n\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).\n\n\nsource\n\n\n\u2013->\n\n\n#\n\n\nFatGraphs.a_star\n \u2014 \nFunction\n.\n\n\na_star(g, s, t, distmx=DefaultDistance(), heuristic = n->0)\n\n\n\n\nComputes the shortest path between vertices \ns\n and \nt\n using the \nA* search algorithm\n. An optional heuristic function and edge distance matrix may be supplied.\n\n\nsource\n\n\n#\n\n\nFatGraphs.dijkstra_shortest_paths\n \u2014 \nFunction\n.\n\n\ndijkstra_shortest_paths(g, s, distmx=DefaultDistance(); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=DefaultDistance(); allpaths=false)\n\n\n\n\nPerforms \nDijkstra's algorithm\n on a graph, computing shortest distances between a source vertex \ns\n (or a vector \nsources\n)  and all other veritces. Returns a \nDijkstraState\n that contains various traversal information.\n\n\nWith \nallpaths=true\n, returns a \nDijkstraState\n that keeps track of all predecessors of a given vertex.\n\n\nsource\n\n\n#\n\n\nFatGraphs.bellman_ford_shortest_paths\n \u2014 \nFunction\n.\n\n\nbellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, sources, distmx=DefaultDistance())\n\n\n\n\nUses the \nBellman-Ford algorithm\n to compute shortest paths of all vertices of a \ng\n from a source vertex \ns\n (or a set of source vertices \nsources\n). Returns a \nBellmanFordState\n with relevant traversal information (see below).\n\n\nsource\n\n\n#\n\n\nFatGraphs.floyd_warshall_shortest_paths\n \u2014 \nFunction\n.\n\n\nfloyd_warshall_shortest_paths(g, distmx=DefaultDistance())\n\n\n\n\nUses the \nFloyd-Warshall algorithm\n to compute shortest paths between all pairs of vertices in graph \ng\n. Returns a \nFloydWarshallState\n with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.\n\n\nNote that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).\n\n\nsource\n\n\n\n\nPath discovery / enumeration\n\n\n#\n\n\nFatGraphs.enumerate_paths\n \u2014 \nFunction\n.\n\n\nenumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)\n\n\n\n\nGiven a path state \nstate\n of type \nAbstractPathState\n (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex \nv\n, a set of destination vertices \nvs\n, or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\nsource\n\n\nFor Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices: \nenumerate_paths(state)\n will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths. \nenumerate_paths(state, v)\n will return a vector (indexed by destination vertex) of paths from source \nv\n to all other vertices. In addition, \nenumerate_paths(state, v, d)\n will return a vector representing the path from vertex \nv\n to vertex \nd\n.\n\n\n\n\nPath States\n\n\nThe \nfloyd_warshall_shortest_paths\n, \nbellman_ford_shortest_paths\n, \ndijkstra_shortest_paths\n, and \ndijkstra_predecessor_and_distance\n functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:\n\n\n.dists\n Holds a vector of distances computed, indexed by source vertex.\n\n\n.parents\n Holds a vector of parents of each source vertex. The parent of a source vertex is always \n0\n.\n\n\nIn addition, the \ndijkstra_predecessor_and_distance\n function stores the following information:\n\n\n.predecessors\n Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.\n\n\n.pathcounts\n Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the \n.predecessors\n output above.",
            "title": "Shortest Paths"
        },
        {
            "location": "/shortestpaths/#shortest-path-algorithms",
            "text": "",
            "title": "Shortest-Path Algorithms"
        },
        {
            "location": "/shortestpaths/#general-properties-of-shortest-path-algorithms",
            "text": "The distance from a vertex to itself is always  0 .  The distance between two vertices with no connecting edge is always  Inf .",
            "title": "General properties of shortest path algorithms"
        },
        {
            "location": "/shortestpaths/#shortest-path-algorithms_1",
            "text": "#  FatGraphs.a_star  \u2014  Function .  a_star(g, s, t, distmx=DefaultDistance(), heuristic = n->0)  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied.  source  #  FatGraphs.bellman_ford_shortest_paths  \u2014  Function .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, sources, distmx=DefaultDistance())  Uses the  Bellman-Ford algorithm  to compute shortest paths of all vertices of a  g  from a source vertex  s  (or a set of source vertices  sources ). Returns a  BellmanFordState  with relevant traversal information (see below).  source  #  FatGraphs.enumerate_paths  \u2014  Method .  enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  #  FatGraphs.dijkstra_shortest_paths  \u2014  Function .  dijkstra_shortest_paths(g, s, distmx=DefaultDistance(); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=DefaultDistance(); allpaths=false)  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  (or a vector  sources )  and all other veritces. Returns a  DijkstraState  that contains various traversal information.  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex.  source  #  FatGraphs.floyd_warshall_shortest_paths  \u2014  Function .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance())  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).  source  \u2013->  #  FatGraphs.a_star  \u2014  Function .  a_star(g, s, t, distmx=DefaultDistance(), heuristic = n->0)  Computes the shortest path between vertices  s  and  t  using the  A* search algorithm . An optional heuristic function and edge distance matrix may be supplied.  source  #  FatGraphs.dijkstra_shortest_paths  \u2014  Function .  dijkstra_shortest_paths(g, s, distmx=DefaultDistance(); allpaths=false)\ndijkstra_shortest_paths(g, sources, distmx=DefaultDistance(); allpaths=false)  Performs  Dijkstra's algorithm  on a graph, computing shortest distances between a source vertex  s  (or a vector  sources )  and all other veritces. Returns a  DijkstraState  that contains various traversal information.  With  allpaths=true , returns a  DijkstraState  that keeps track of all predecessors of a given vertex.  source  #  FatGraphs.bellman_ford_shortest_paths  \u2014  Function .  bellman_ford_shortest_paths(g, s, distmx=DefaultDistance())\nbellman_ford_shortest_paths(g, sources, distmx=DefaultDistance())  Uses the  Bellman-Ford algorithm  to compute shortest paths of all vertices of a  g  from a source vertex  s  (or a set of source vertices  sources ). Returns a  BellmanFordState  with relevant traversal information (see below).  source  #  FatGraphs.floyd_warshall_shortest_paths  \u2014  Function .  floyd_warshall_shortest_paths(g, distmx=DefaultDistance())  Uses the  Floyd-Warshall algorithm  to compute shortest paths between all pairs of vertices in graph  g . Returns a  FloydWarshallState  with relevant traversal information, each is a vertex-indexed vector of vectors containing the metric for each vertex in the graph.  Note that this algorithm may return a large amount of data (it will allocate on the order of $O(nv^2)$).  source",
            "title": "Shortest-Path Algorithms"
        },
        {
            "location": "/shortestpaths/#path-discovery-enumeration",
            "text": "#  FatGraphs.enumerate_paths  \u2014  Function .  enumerate_paths(state::AbstractPathState)\nenumerate_paths(state::AbstractPathState, dest)  Given a path state  state  of type  AbstractPathState  (see below), returns a vector (indexed by vertex) of the paths between the source vertex used to compute the path state and a destination vertex  v , a set of destination vertices  vs , or the entire graph. For multiple destination vertices, each path is represented by a vector of vertices on the path between the source and the destination. Nonexistent paths will be indicated by an empty vector. For single destinations, the path is represented by a single vector of vertices, and will be length 0 if the path does not exist.  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .  source  For Floyd-Warshall path states, please note that the output is a bit different, since this algorithm calculates all shortest paths for all pairs of vertices:  enumerate_paths(state)  will return a vector (indexed by source vertex) of vectors (indexed by destination vertex) of paths.  enumerate_paths(state, v)  will return a vector (indexed by destination vertex) of paths from source  v  to all other vertices. In addition,  enumerate_paths(state, v, d)  will return a vector representing the path from vertex  v  to vertex  d .",
            "title": "Path discovery / enumeration"
        },
        {
            "location": "/shortestpaths/#path-states",
            "text": "The  floyd_warshall_shortest_paths ,  bellman_ford_shortest_paths ,  dijkstra_shortest_paths , and  dijkstra_predecessor_and_distance  functions return a state that contains various information about the graph learned during traversal. The three state types have the following common information, accessible via the type:  .dists  Holds a vector of distances computed, indexed by source vertex.  .parents  Holds a vector of parents of each source vertex. The parent of a source vertex is always  0 .  In addition, the  dijkstra_predecessor_and_distance  function stores the following information:  .predecessors  Holds a vector, indexed by vertex, of all the predecessors discovered during shortest-path calculations. This keeps track of all parents when there are multiple shortest paths available from the source.  .pathcounts  Holds a vector, indexed by vertex, of the path counts discovered during traversal. This equals the length of each subvector in the  .predecessors  output above.",
            "title": "Path States"
        },
        {
            "location": "/linalg/",
            "text": "Linear Algebra\n\n\nFatGraphs.jl\n provides the following matrix operations on both directed and undirected graphs:\n\n\n#\n\n\nFatGraphs.adjacency_matrix\n \u2014 \nFunction\n.\n\n\nadjacency_matrix(g, dir=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse boolean adjacency matrix for a graph, indexed by \n[u, v]\n vertices. \ntrue\n values indicate an edge between \nu\n and \nv\n. Users may specify a direction (\n:in\n, \n:out\n, or \n:all\n are currently supported; \n:out\n is default for both directed and undirected graphs) and a data type for the matrix (defaults to \nInt\n).\n\n\nsource\n\n\n#\n\n\nFatGraphs.adjacency_spectrum\n \u2014 \nFunction\n.\n\n\nReturns the eigenvalues of the adjacency matrix for a graph \ng\n, indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use \neigs(adjacency_matrix(g);kwargs...)\n to compute some of the eigenvalues/eigenvectors. Default values for \ndir\n and \nT\n are the same as \nadjacency_matrix\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.incidence_matrix\n \u2014 \nFunction\n.\n\n\nincidence_matrix(g::ASimpleGraph, T::DataType=Int; oriented=false)\n\n\n\n\nReturns a sparse node-arc incidence matrix for a graph, indexed by \n[v, i]\n, where \ni\n is in \n1:ne(g)\n, indexing an edge \ne\n. For directed graphs, a value of \n-1\n indicates that \nsrc(e) == v\n, while a value of \n1\n indicates that \ndst(e) == v\n. Otherwise, the value is \n0\n.\n\n\nFor undirected graphs, both entries are \n1\n if \noriented=false\n, otherwise \n[v, i] -> -1\n and \n[u, i] -> 1\n if \nv < u\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.laplacian_matrix\n \u2014 \nFunction\n.\n\n\nlaplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)\n\n\n\n\nReturns a sparse \nLaplacian matrix\n for a graph \ng\n, indexed by \n[u, v]\n vertices. \ndir\n has to be \n:in, :out\n or \n:all\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.laplacian_spectrum\n \u2014 \nFunction\n.\n\n\nlaplacian_spectrum(g, dir::Symbol=:out, T::DataType=Int)\n\n\n\n\nReturns the eigenvalues of the Laplacian matrix for a graph \ng\n, indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use \neigs(laplacian_matrix(g);  kwargs...)\n to compute some of the eigenvalues/eigenvectors. Default values for \ndir\n and \nT\n are the same as \nlaplacian_matrix\n. \ndir\n has to be \n:in, :out\n or \n:all\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.spectral_distance\n \u2014 \nMethod\n.\n\n\nspectral_distance(G\u2081, G\u2082 [, k])\n\n\n\n\nCompute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.\n\n\nFor further details, please refer to:\n\n\nJOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations\n\n\nsource",
            "title": "Linear Algebra"
        },
        {
            "location": "/linalg/#linear-algebra",
            "text": "FatGraphs.jl  provides the following matrix operations on both directed and undirected graphs:  #  FatGraphs.adjacency_matrix  \u2014  Function .  adjacency_matrix(g, dir=:out, T::DataType=Int)  Returns a sparse boolean adjacency matrix for a graph, indexed by  [u, v]  vertices.  true  values indicate an edge between  u  and  v . Users may specify a direction ( :in ,  :out , or  :all  are currently supported;  :out  is default for both directed and undirected graphs) and a data type for the matrix (defaults to  Int ).  source  #  FatGraphs.adjacency_spectrum  \u2014  Function .  Returns the eigenvalues of the adjacency matrix for a graph  g , indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use  eigs(adjacency_matrix(g);kwargs...)  to compute some of the eigenvalues/eigenvectors. Default values for  dir  and  T  are the same as  adjacency_matrix .  source  #  FatGraphs.incidence_matrix  \u2014  Function .  incidence_matrix(g::ASimpleGraph, T::DataType=Int; oriented=false)  Returns a sparse node-arc incidence matrix for a graph, indexed by  [v, i] , where  i  is in  1:ne(g) , indexing an edge  e . For directed graphs, a value of  -1  indicates that  src(e) == v , while a value of  1  indicates that  dst(e) == v . Otherwise, the value is  0 .  For undirected graphs, both entries are  1  if  oriented=false , otherwise  [v, i] -> -1  and  [u, i] -> 1  if  v < u .  source  #  FatGraphs.laplacian_matrix  \u2014  Function .  laplacian_matrix(g, dir::Symbol=:out, T::DataType=Int)  Returns a sparse  Laplacian matrix  for a graph  g , indexed by  [u, v]  vertices.  dir  has to be  :in, :out  or  :all .  source  #  FatGraphs.laplacian_spectrum  \u2014  Function .  laplacian_spectrum(g, dir::Symbol=:out, T::DataType=Int)  Returns the eigenvalues of the Laplacian matrix for a graph  g , indexed by vertex. Warning: Converts the matrix to dense with $nv^2$ memory usage. Use  eigs(laplacian_matrix(g);  kwargs...)  to compute some of the eigenvalues/eigenvectors. Default values for  dir  and  T  are the same as  laplacian_matrix .  dir  has to be  :in, :out  or  :all .  source  #  FatGraphs.spectral_distance  \u2014  Method .  spectral_distance(G\u2081, G\u2082 [, k])  Compute the spectral distance between undirected n-vertex graphs G\u2081 and G\u2082 using the top k \u2264 n greatest eigenvalues. If k is ommitted, uses full spectrum.  For further details, please refer to:  JOVANOVIC, I.; STANIC, Z., 2014. Spectral Distances of Graphs Based on their Different Matrix Representations  source",
            "title": "Linear Algebra"
        },
        {
            "location": "/persistence/",
            "text": "Reading and writing Graphs\n\n\nGraphs may be written to I/O streams and files using the \nwritegraph\n function and read with the \nreadgraph\n function. Currently supported common graph formats are \ngml, graphml, gexf, dot\n and \nPajek .NET\n.\n\n\n#\n\n\nFatGraphs.readgraph\n \u2014 \nMethod\n.\n\n\nreadgraph(file, t)\n\n\n\n\nReads a graph from  \nfile\n in the format \nt\n.\n\n\nSupported formats are \n:gml, :dot, :graphml, :gexf, :NET, :jld\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.writegraph\n \u2014 \nMethod\n.\n\n\nwritegraph(file, g, t; compress=false)\n\n\n\n\nSave a graph \ng\n to \nfile\n in the format \nt\n.\n\n\nEventually the resulting file can be compressed in the gzip format.\n\n\nCurrently supported formats are \n:lg, :gml, :graphml, :gexf, :dot, :NET\n.\n\n\nsource\n\n\n\n\nExamples\n\n\nwritegraph(STDOUT, g)\nwritegraph(\"mygraph.gml\", g, :gml)\nwritegraph(\"mygraph.dot.gzip\", g, :dot, compress=true)\n\ng = readgraph(\"mygraph.dot.gzip\", :dot)\ng = readgraph(\"mygraphs.graphml\", :graphml)\ng = readgraph(\"mygraph.gml\", :gml)",
            "title": "Reading / Writing Graphs"
        },
        {
            "location": "/persistence/#reading-and-writing-graphs",
            "text": "Graphs may be written to I/O streams and files using the  writegraph  function and read with the  readgraph  function. Currently supported common graph formats are  gml, graphml, gexf, dot  and  Pajek .NET .  #  FatGraphs.readgraph  \u2014  Method .  readgraph(file, t)  Reads a graph from   file  in the format  t .  Supported formats are  :gml, :dot, :graphml, :gexf, :NET, :jld .  source  #  FatGraphs.writegraph  \u2014  Method .  writegraph(file, g, t; compress=false)  Save a graph  g  to  file  in the format  t .  Eventually the resulting file can be compressed in the gzip format.  Currently supported formats are  :lg, :gml, :graphml, :gexf, :dot, :NET .  source",
            "title": "Reading and writing Graphs"
        },
        {
            "location": "/persistence/#examples",
            "text": "writegraph(STDOUT, g)\nwritegraph(\"mygraph.gml\", g, :gml)\nwritegraph(\"mygraph.dot.gzip\", g, :dot, compress=true)\n\ng = readgraph(\"mygraph.dot.gzip\", :dot)\ng = readgraph(\"mygraphs.graphml\", :graphml)\ng = readgraph(\"mygraph.gml\", :gml)",
            "title": "Examples"
        },
        {
            "location": "/generators/",
            "text": "Generators\n\n\n\n\nRandom Graphs\n\n\nFatGraphs.jl\n implements some common random graph generators:\n\n\n#\n\n\nFatGraphs.barabasi_albert\n \u2014 \nFunction\n.\n\n\nbarabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)\n\n\n\n\nCreates a random graph of type \nG\n with \nn\n vertices according to \nBarab\u00e1si\u2013Albert model\n. It is grown by adding new vertices to an initial graph with \nn0\n vertices (\nn0=k\n if not specified). Each new vertex is attached with \nk\n edges to \nk\n different vertices already present in the system by preferential attachment. The initial graph is empty by default.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nSee also \nbarabasi_albert!\n for growing a given graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.barabasi_albert!\n \u2014 \nMethod\n.\n\n\nbarabasi_albert!(g, n::Int, k::Int; seed::Int = -1)\n\n\n\n\nGrows the graph \ng\n according to \nBarab\u00e1si\u2013Albert\n process into a graph with \nn\n vertices. At each step a new vertex is attached by preferential attachment to \nk\n different vertices already present in the graph.\n\n\nSee also \nbarabasi_albert\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.erdos_renyi\n \u2014 \nFunction\n.\n\n\nerdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)\n\n\n\n\nCreates an \nErd\u0151s\u2013R\u00e9nyi\n random graph of type \nG\n with \nn\n vertices. Edges are added between pairs of vertices with probability \np\n in the first method. In the second method \nm\n edges are randomly chosen insted.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n)\n\n\nNote also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using \nerdos_renyi(n, ne)\n or the  \nGraph(nv, ne)\n constructor, which randomly select \nne\n edges among all the potential edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.random_configuration_model\n \u2014 \nFunction\n.\n\n\nrandom_configuration_model(n::Int, k::Array{Int}; seed=-1, check_graphical=false)\n\n\n\n\nCreates a random undirected graph according to the \nconfiguraton model\n. It contains \nn\n vertices, the vertex \ni\n having degree \nk[i]\n.\n\n\nDefining \nc = mean(k)\n, it allocates an array of \nnc\n \nInt\ns, and takes approximately $nc^2$ time.\n\n\nIf \ncheck_graphical=true\n makes sure that \nk\n is a graphical sequence (see \nisgraphical\n).\n\n\nsource\n\n\n#\n\n\nFatGraphs.random_regular_digraph\n \u2014 \nFunction\n.\n\n\nrandom_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)\n\n\n\n\nCreates a random directed \nregular graph\n with \nn\n vertices, each with degree \nk\n. The degree (in or out) can be specified using \ndir=:in\n or \ndir=:out\n. The default is \ndir=:out\n.\n\n\nFor directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.random_regular_graph\n \u2014 \nFunction\n.\n\n\nrandom_regular_graph(n::Int, k::Int; seed=-1)\n\n\n\n\nCreates a random undirected \nregular graph\n with \nn\n vertices, each with degree \nk\n.\n\n\nFor undirected graphs, allocates an array of \nnk\n \nInt\ns, and takes approximately $nk^2$ time. For $k > n/2$, generates a graph of degree \nn-k-1\n and returns its complement.\n\n\nsource\n\n\n#\n\n\nFatGraphs.static_fitness_model\n \u2014 \nFunction\n.\n\n\nstatic_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)\n\n\n\n\nGenerates a random graph with \nlength(fitness)\n nodes and \nm\n edges, in which the probability of the existence of edge \n(i, j)\n is proportional to \nfitness[i]*fitness[j]\n. Time complexity is O(|V| + |E| log |E|).\n\n\nIn and out fitness have to be supplied for generating directed graphs.\n\n\nReference:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution\n\n\n\n\nin scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nsource\n\n\n#\n\n\nFatGraphs.static_scale_free\n \u2014 \nFunction\n.\n\n\nfunction static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random graph with \nn\n vertices, \nm\n edges and expected power-law degree distribution with exponent \n\u03b1\n. \nfinite_size_correction\n determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the \nstatic_fitness_model function\n. Time complexity is O(|V| + |E| log |E|).\n\n\nfunction static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)\n\n\n\n\nGenerates a random digraph\n\n\nReferences:\n\n\n\n\nGoh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.\n\n\nChung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.\n\n\nCho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.stochastic_block_model\n \u2014 \nFunction\n.\n\n\nstochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)\n\n\n\n\nReturns a Graph generated according to the Stochastic Block Model (SBM).\n\n\nc[a,b]\n : Mean number of neighbors of a vertex in block \na\n belonging to block \nb\n.            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$. \nn[a]\n : Number of vertices in block \na\n\n\nThe second form samples from a SBM with \nc[a,a]=cin\n, and \nc[a,b]=coff\n.\n\n\nFor a dynamic version of the SBM see the \nStochasticBlockModel\n type and related functions.\n\n\nsource\n\n\n#\n\n\nFatGraphs.watts_strogatz\n \u2014 \nFunction\n.\n\n\nwatts_strogatz(n, k, \u03b2, G=Graph; seed=-1)\n\n\n\n\nCreates a \nWatts-Strogatz\n small model random graph with \nn\n vertices, each with degree \nk\n. Edges are randomized per the model based on probability \n\u03b2\n.\n\n\nUndirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g. \nDiGraph\n).\n\n\nsource\n\n\n\n\nStatic Graphs\n\n\nFatGraphs.jl\n also implements a collection of classic graph generators:\n\n\n#\n\n\nFatGraphs.BinaryTree\n \u2014 \nFunction\n.\n\n\nBinaryTree(levels, G=Graph)\n\n\n\n\nCreates a binary tree with k-levels vertices are numbered 1:2^levels-1\n\n\nsource\n\n\n#\n\n\nFatGraphs.CliqueGraph\n \u2014 \nFunction\n.\n\n\nCliqueGraph(k, n, G=Graph)\n\n\n\n\nThis function generates a graph with \nn\n \nk\n-cliques connected circularly by \nn\n edges.\n\n\nsource\n\n\n#\n\n\nFatGraphs.CompleteBipartiteGraph\n \u2014 \nFunction\n.\n\n\nCompleteBipartiteGraph(n1, n2, G = Graph)\n\n\n\n\nCreates a complete bipartite graph with \nn1+n2\n vertices. It has edges connecting each pair of vertices in the two sets.\n\n\nsource\n\n\n#\n\n\nFatGraphs.CompleteDiGraph\n \u2014 \nFunction\n.\n\n\nCompleteDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a complete digraph with \nn\n vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).\n\n\nsource\n\n\n#\n\n\nFatGraphs.CompleteGraph\n \u2014 \nFunction\n.\n\n\nCompleteGraph(n, G = Graph)\n\n\n\n\nCreates a complete graph of type \nG\n with \nn\n vertices. A complete graph has edges connecting each pair of vertices.\n\n\nsource\n\n\n#\n\n\nFatGraphs.CycleDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a cycle digraph with \nn\n vertices. A cycle digraph is a closed path digraph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.CycleGraph\n \u2014 \nFunction\n.\n\n\nCycleGraph(n, G=Graph)\n\n\n\n\nCreates a cycle graph with \nn\n vertices. A cycle graph is a closed path graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.DoubleBinaryTree\n \u2014 \nFunction\n.\n\n\nDoubleBinaryTree(levels, G=Graph)\n\n\n\n\nCreate a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.\n\n\nsource\n\n\n#\n\n\nFatGraphs.Grid\n \u2014 \nFunction\n.\n\n\nGrid{T<:Integer}(dims::AbstractVector{T}; periodic=false)\n\n\n\n\nCreates a \nd\n-dimensional cubic lattice, with \nd=length(dims)\n and length  \ndims[i]\n in dimension \ni\n. If \nperiodic=true\n the resulting lattice will have periodic boundary condition in each dimension.\n\n\nsource\n\n\n#\n\n\nFatGraphs.PathDiGraph\n \u2014 \nFunction\n.\n\n\nPathDiGraph(n, G = DiGraph)\n\n\n\n\nCreates a path digraph with \nn\n vertices. A path graph connects each successive vertex by a single directed edge.\n\n\nsource\n\n\n#\n\n\nFatGraphs.PathGraph\n \u2014 \nFunction\n.\n\n\nPathGraph(n, G = Graph)\n\n\n\n\nCreates a path graph with \nn\n vertices. A path graph connects each successive vertex by a single edge.\n\n\nsource\n\n\n#\n\n\nFatGraphs.RoachGraph\n \u2014 \nFunction\n.\n\n\nThe Roach Graph from Guattery and Miller 1998\n\n\nsource\n\n\n#\n\n\nFatGraphs.StarDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a star digraph with \nn\n vertices. A star digraph has a central vertex with directed edges to every other vertex.\n\n\nsource\n\n\n#\n\n\nFatGraphs.StarGraph\n \u2014 \nFunction\n.\n\n\nStarGraph(n, G = Graph)\n\n\n\n\nCreates a star graph with \nn\n vertices. A star graph has a central vertex with edges to each other vertex.\n\n\nsource\n\n\n#\n\n\nFatGraphs.WheelDiGraph\n \u2014 \nFunction\n.\n\n\nCreates a wheel digraph with \nn\n vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n#\n\n\nFatGraphs.WheelGraph\n \u2014 \nFunction\n.\n\n\nWheelGraph(n, G=Graph)\n\n\n\n\nCreates a wheel graph with \nn\n vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.\n\n\nsource\n\n\n\n\nSmall Graphs\n\n\nOther classical graphs can be generated by the following function:\n\n\n#\n\n\nFatGraphs.digraph\n \u2014 \nFunction\n.\n\n\ndigraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a digraph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.digraph\n \u2014 \nFunction\n.\n\n\ndigraph(s::Symbol, G = DiGraph)\n\n\n\n\nCreates a notorious digraph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.graph\n \u2014 \nFunction\n.\n\n\ngraph(s::Symbol, G = Graph)\n\n\n\n\nCreates a notorious graph \ns\n of type \nG\n. Admissible values for \ns\n are:\n\n\n\n\n\n\n\n\ns\n\n\ngraph type\n\n\n\n\n\n\n\n\n\n\n:bull\n\n\nA \nbull graph\n.\n\n\n\n\n\n\n:chvatal\n\n\nA \nChv\u00e1tal graph\n.\n\n\n\n\n\n\n:cubical\n\n\nA \nPlatonic cubical graph\n.\n\n\n\n\n\n\n:desargues\n\n\nA \nDesarguesgraph\n.\n\n\n\n\n\n\n:diamond\n\n\nA \ndiamond graph\n.\n\n\n\n\n\n\n:dodecahedral\n\n\nA \nPlatonic dodecahedral  graph\n.\n\n\n\n\n\n\n:frucht\n\n\nA \nFrucht graph\n.\n\n\n\n\n\n\n:heawood\n\n\nA \nHeawood graph\n.\n\n\n\n\n\n\n:house\n\n\nA graph mimicing the classic outline of a house.\n\n\n\n\n\n\n:housex\n\n\nA house graph, with two edges crossing the bottom square.\n\n\n\n\n\n\n:icosahedral\n\n\nA \nPlatonic icosahedral   graph\n.\n\n\n\n\n\n\n:krackhardtkite\n\n\nA \nKrackhardt-Kite social network  graph\n.\n\n\n\n\n\n\n:moebiuskantor\n\n\nA \nM\u00f6bius-Kantor graph\n.\n\n\n\n\n\n\n:octahedral\n\n\nA \nPlatonic octahedral graph\n.\n\n\n\n\n\n\n:pappus\n\n\nA \nPappus graph\n.\n\n\n\n\n\n\n:petersen\n\n\nA \nPetersen graph\n.\n\n\n\n\n\n\n:sedgewickmaze\n\n\nA simple maze graph used in Sedgewick's \nAlgorithms in C++: Graph  Algorithms (3rd ed.)\n\n\n\n\n\n\n:tetrahedral\n\n\nA \nPlatonic tetrahedral  graph\n.\n\n\n\n\n\n\n:truncatedcube\n\n\nA skeleton of the \ntruncated cube graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron\n\n\nA skeleton of the \ntruncated tetrahedron  graph\n.\n\n\n\n\n\n\n:truncatedtetrahedron_dir\n\n\nA skeleton of the \ntruncated tetrahedron digraph\n.\n\n\n\n\n\n\n:tutte\n\n\nA \nTutte graph\n.\n\n\n\n\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.graph\n \u2014 \nFunction\n.\n\n\ngraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)\n\n\n\n\nBuild a graph with \nn\n vertices, type \nG\n, and given \nedgelist\n.\n\n\nsource\n\n\n\n\nEuclidean Graphs\n\n\nGeneration of random and static graphs embedded in Euclidean space.\n\n\n#\n\n\nFatGraphs.euclidean_graph\n \u2014 \nFunction\n.\n\n\neuclidean_graph(points::Matrix G=Graph; L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGiven the \nd\u00d7N\n matrix \npoints\n builds an Euclidean graph of \nN\n vertices according to the following procedure.\n\n\nDefining the \nd\n-dimensional vectors \nx[i] = points[:,i]\n, an edge between vertices \ni\n and \nj\n is inserted if \nnorm(x[i]-x[j], p) < cutoff\n. In case of negative \ncutoff\n instead every edge is inserted. For \np=2\n we have the standard Euclidean distance. Set \nbc=:periodic\n to impose periodic boundary conditions in the box $[0,L]^d$.\n\n\nReturns a graph and Dict containing the distance on each edge.\n\n\neuclidean_graph(N, d, G=Graph; seed = -1, L=1., p=2., cutoff=-1., bc=:open)\n\n\n\n\nGenerates \nN\n uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.\n\n\nReturns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.\n\n\nsource\n\n\n\n\nMatrixDepot\n\n\nOther notorious graphs are available through integration with the \nMatrixDepot.jl\n package.",
            "title": "Graph Generators"
        },
        {
            "location": "/generators/#generators",
            "text": "",
            "title": "Generators"
        },
        {
            "location": "/generators/#random-graphs",
            "text": "FatGraphs.jl  implements some common random graph generators:  #  FatGraphs.barabasi_albert  \u2014  Function .  barabasi_albert(n, k, G=Graph; seed=-1)\nbarabasi_albert(n, n0, k, G=Graph; seed=-1)  Creates a random graph of type  G  with  n  vertices according to  Barab\u00e1si\u2013Albert model . It is grown by adding new vertices to an initial graph with  n0  vertices ( n0=k  if not specified). Each new vertex is attached with  k  edges to  k  different vertices already present in the system by preferential attachment. The initial graph is empty by default.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  See also  barabasi_albert!  for growing a given graph.  source  #  FatGraphs.barabasi_albert!  \u2014  Method .  barabasi_albert!(g, n::Int, k::Int; seed::Int = -1)  Grows the graph  g  according to  Barab\u00e1si\u2013Albert  process into a graph with  n  vertices. At each step a new vertex is attached by preferential attachment to  k  different vertices already present in the graph.  See also  barabasi_albert .  source  #  FatGraphs.erdos_renyi  \u2014  Function .  erdos_renyi(n::Int, p::Real, G=Graph; seed=-1)\nerdos_renyi(n::Int, m::Int, G=Graph; seed=-1)  Creates an  Erd\u0151s\u2013R\u00e9nyi  random graph of type  G  with  n  vertices. Edges are added between pairs of vertices with probability  p  in the first method. In the second method  m  edges are randomly chosen insted.  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph )  Note also that Erd\u0151s\u2013R\u00e9nyi graphs may be generated quickly using  erdos_renyi(n, ne)  or the   Graph(nv, ne)  constructor, which randomly select  ne  edges among all the potential edges.  source  #  FatGraphs.random_configuration_model  \u2014  Function .  random_configuration_model(n::Int, k::Array{Int}; seed=-1, check_graphical=false)  Creates a random undirected graph according to the  configuraton model . It contains  n  vertices, the vertex  i  having degree  k[i] .  Defining  c = mean(k) , it allocates an array of  nc   Int s, and takes approximately $nc^2$ time.  If  check_graphical=true  makes sure that  k  is a graphical sequence (see  isgraphical ).  source  #  FatGraphs.random_regular_digraph  \u2014  Function .  random_regular_digraph(n::Int, k::Int; dir::Symbol=:out, seed=-1)  Creates a random directed  regular graph  with  n  vertices, each with degree  k . The degree (in or out) can be specified using  dir=:in  or  dir=:out . The default is  dir=:out .  For directed graphs, allocates an $n    imes n$ sparse matrix of boolean as an adjacency matrix and uses that to generate the directed graph.  source  #  FatGraphs.random_regular_graph  \u2014  Function .  random_regular_graph(n::Int, k::Int; seed=-1)  Creates a random undirected  regular graph  with  n  vertices, each with degree  k .  For undirected graphs, allocates an array of  nk   Int s, and takes approximately $nk^2$ time. For $k > n/2$, generates a graph of degree  n-k-1  and returns its complement.  source  #  FatGraphs.static_fitness_model  \u2014  Function .  static_fitness_model(m, fitness, G=Graph; seed=-1)\nstatic_fitness_model(m, fitness_out, fitness_in, G=DiGraph; seed=-1)  Generates a random graph with  length(fitness)  nodes and  m  edges, in which the probability of the existence of edge  (i, j)  is proportional to  fitness[i]*fitness[j] . Time complexity is O(|V| + |E| log |E|).  In and out fitness have to be supplied for generating directed graphs.  Reference:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution   in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  source  #  FatGraphs.static_scale_free  \u2014  Function .  function static_scale_free(n, m, \u03b1, G=Graph;\n        seed=-1, finite_size_correction=true)  Generates a random graph with  n  vertices,  m  edges and expected power-law degree distribution with exponent  \u03b1 .  finite_size_correction  determines whether to use the finite size correction proposed by Cho et al. This generator calls internally the  static_fitness_model function . Time complexity is O(|V| + |E| log |E|).  function static_scale_free(n, m, \u03b1_out, \u03b1_in, G=DiGraph;\n        seed=-1, finite_size_correction=true)  Generates a random digraph  References:   Goh K-I, Kahng B, Kim D: Universal behaviour of load distribution in scale-free networks. Phys Rev Lett 87(27):278701, 2001.  Chung F and Lu L: Connected components in a random graph with given degree sequences. Annals of Combinatorics 6, 125-145, 2002.  Cho YS, Kim JS, Park J, Kahng B, Kim D: Percolation transitions in scale-free networks under the Achlioptas process. Phys Rev Lett 103:135702, 2009.   source  #  FatGraphs.stochastic_block_model  \u2014  Function .  stochastic_block_model(c::Matrix{Float64}, n::Vector{Int}; seed::Int = -1)\nstochastic_block_model(cin::Float64, coff::Float64, n::Vector{Int}; seed::Int = -1)  Returns a Graph generated according to the Stochastic Block Model (SBM).  c[a,b]  : Mean number of neighbors of a vertex in block  a  belonging to block  b .            Only the upper triangular part is considered, since the lower traingular is            determined by $c[b,a] = c[a,b] * n[a]/n[b]$.  n[a]  : Number of vertices in block  a  The second form samples from a SBM with  c[a,a]=cin , and  c[a,b]=coff .  For a dynamic version of the SBM see the  StochasticBlockModel  type and related functions.  source  #  FatGraphs.watts_strogatz  \u2014  Function .  watts_strogatz(n, k, \u03b2, G=Graph; seed=-1)  Creates a  Watts-Strogatz  small model random graph with  n  vertices, each with degree  k . Edges are randomized per the model based on probability  \u03b2 .  Undirected graphs are created by default. Directed graphs can be created passing a directed graph type as last argument (e.g.  DiGraph ).  source",
            "title": "Random Graphs"
        },
        {
            "location": "/generators/#static-graphs",
            "text": "FatGraphs.jl  also implements a collection of classic graph generators:  #  FatGraphs.BinaryTree  \u2014  Function .  BinaryTree(levels, G=Graph)  Creates a binary tree with k-levels vertices are numbered 1:2^levels-1  source  #  FatGraphs.CliqueGraph  \u2014  Function .  CliqueGraph(k, n, G=Graph)  This function generates a graph with  n   k -cliques connected circularly by  n  edges.  source  #  FatGraphs.CompleteBipartiteGraph  \u2014  Function .  CompleteBipartiteGraph(n1, n2, G = Graph)  Creates a complete bipartite graph with  n1+n2  vertices. It has edges connecting each pair of vertices in the two sets.  source  #  FatGraphs.CompleteDiGraph  \u2014  Function .  CompleteDiGraph(n, G = DiGraph)  Creates a complete digraph with  n  vertices. A complete digraph has edges connecting each pair of vertices (both an ingoing and outgoing edge).  source  #  FatGraphs.CompleteGraph  \u2014  Function .  CompleteGraph(n, G = Graph)  Creates a complete graph of type  G  with  n  vertices. A complete graph has edges connecting each pair of vertices.  source  #  FatGraphs.CycleDiGraph  \u2014  Function .  Creates a cycle digraph with  n  vertices. A cycle digraph is a closed path digraph.  source  #  FatGraphs.CycleGraph  \u2014  Function .  CycleGraph(n, G=Graph)  Creates a cycle graph with  n  vertices. A cycle graph is a closed path graph.  source  #  FatGraphs.DoubleBinaryTree  \u2014  Function .  DoubleBinaryTree(levels, G=Graph)  Create a double complete binary tree with k-levels used as an example for spectral clustering by Guattery and Miller 1998.  source  #  FatGraphs.Grid  \u2014  Function .  Grid{T<:Integer}(dims::AbstractVector{T}; periodic=false)  Creates a  d -dimensional cubic lattice, with  d=length(dims)  and length   dims[i]  in dimension  i . If  periodic=true  the resulting lattice will have periodic boundary condition in each dimension.  source  #  FatGraphs.PathDiGraph  \u2014  Function .  PathDiGraph(n, G = DiGraph)  Creates a path digraph with  n  vertices. A path graph connects each successive vertex by a single directed edge.  source  #  FatGraphs.PathGraph  \u2014  Function .  PathGraph(n, G = Graph)  Creates a path graph with  n  vertices. A path graph connects each successive vertex by a single edge.  source  #  FatGraphs.RoachGraph  \u2014  Function .  The Roach Graph from Guattery and Miller 1998  source  #  FatGraphs.StarDiGraph  \u2014  Function .  Creates a star digraph with  n  vertices. A star digraph has a central vertex with directed edges to every other vertex.  source  #  FatGraphs.StarGraph  \u2014  Function .  StarGraph(n, G = Graph)  Creates a star graph with  n  vertices. A star graph has a central vertex with edges to each other vertex.  source  #  FatGraphs.WheelDiGraph  \u2014  Function .  Creates a wheel digraph with  n  vertices. A wheel graph is a star digraph with the outer vertices connected via a closed path graph.  source  #  FatGraphs.WheelGraph  \u2014  Function .  WheelGraph(n, G=Graph)  Creates a wheel graph with  n  vertices. A wheel graph is a star graph with the outer vertices connected via a closed path graph.  source",
            "title": "Static Graphs"
        },
        {
            "location": "/generators/#small-graphs",
            "text": "Other classical graphs can be generated by the following function:  #  FatGraphs.digraph  \u2014  Function .  digraph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a digraph with  n  vertices, type  G , and given  edgelist .  source  #  FatGraphs.digraph  \u2014  Function .  digraph(s::Symbol, G = DiGraph)  Creates a notorious digraph  s  of type  G . Admissible values for  s  are:     s  graph type      :truncatedtetrahedron  A skeleton of the  truncated tetrahedron digraph .     source  #  FatGraphs.graph  \u2014  Function .  graph(s::Symbol, G = Graph)  Creates a notorious graph  s  of type  G . Admissible values for  s  are:     s  graph type      :bull  A  bull graph .    :chvatal  A  Chv\u00e1tal graph .    :cubical  A  Platonic cubical graph .    :desargues  A  Desarguesgraph .    :diamond  A  diamond graph .    :dodecahedral  A  Platonic dodecahedral  graph .    :frucht  A  Frucht graph .    :heawood  A  Heawood graph .    :house  A graph mimicing the classic outline of a house.    :housex  A house graph, with two edges crossing the bottom square.    :icosahedral  A  Platonic icosahedral   graph .    :krackhardtkite  A  Krackhardt-Kite social network  graph .    :moebiuskantor  A  M\u00f6bius-Kantor graph .    :octahedral  A  Platonic octahedral graph .    :pappus  A  Pappus graph .    :petersen  A  Petersen graph .    :sedgewickmaze  A simple maze graph used in Sedgewick's  Algorithms in C++: Graph  Algorithms (3rd ed.)    :tetrahedral  A  Platonic tetrahedral  graph .    :truncatedcube  A skeleton of the  truncated cube graph .    :truncatedtetrahedron  A skeleton of the  truncated tetrahedron  graph .    :truncatedtetrahedron_dir  A skeleton of the  truncated tetrahedron digraph .    :tutte  A  Tutte graph .     source  #  FatGraphs.graph  \u2014  Function .  graph{G<:AGraph}(n, edgelist::Vector{Tuple{Int,Int}},\n    G = Graph)  Build a graph with  n  vertices, type  G , and given  edgelist .  source",
            "title": "Small Graphs"
        },
        {
            "location": "/generators/#euclidean-graphs",
            "text": "Generation of random and static graphs embedded in Euclidean space.  #  FatGraphs.euclidean_graph  \u2014  Function .  euclidean_graph(points::Matrix G=Graph; L=1., p=2., cutoff=-1., bc=:open)  Given the  d\u00d7N  matrix  points  builds an Euclidean graph of  N  vertices according to the following procedure.  Defining the  d -dimensional vectors  x[i] = points[:,i] , an edge between vertices  i  and  j  is inserted if  norm(x[i]-x[j], p) < cutoff . In case of negative  cutoff  instead every edge is inserted. For  p=2  we have the standard Euclidean distance. Set  bc=:periodic  to impose periodic boundary conditions in the box $[0,L]^d$.  Returns a graph and Dict containing the distance on each edge.  euclidean_graph(N, d, G=Graph; seed = -1, L=1., p=2., cutoff=-1., bc=:open)  Generates  N  uniformly distributed points in the box $[0,L]^d$ and builds and Euclidean graph.  Returns a graph, a Dict containing the distance on each edge and a matrix with the points' positions.  source",
            "title": "Euclidean Graphs"
        },
        {
            "location": "/generators/#matrixdepot",
            "text": "Other notorious graphs are available through integration with the  MatrixDepot.jl  package.",
            "title": "MatrixDepot"
        },
        {
            "location": "/centrality/",
            "text": "Centrality Measures\n\n\nCentrality measures\n describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in \nFatGraphs.jl\n include the following:\n\n\n\n\nFatGraphs.betweenness_centrality\n\n\nFatGraphs.closeness_centrality\n\n\nFatGraphs.degree_centrality\n\n\nFatGraphs.in_degree_centrality\n\n\nFatGraphs.katz_centrality\n\n\nFatGraphs.out_degree_centrality\n\n\nFatGraphs.pagerank\n\n\n\n\n#\n\n\nFatGraphs.betweenness_centrality\n \u2014 \nFunction\n.\n\n\nbetweenness_centrality(g, k=0; normalize=true, endpoints=false)\n\n\n\n\nCalculates the \nbetweenness centrality\n of the graph \ng\n, or, optionally, of a random subset of \nk\n vertices. Can optionally include endpoints in the calculations. Normalization is enabled by default.\n\n\nBetweenness centrality is defined as:\n\n\n$bc(v) = \frac{1}{mathcal{N}} sum_{s  eq t  eq v}         \frac{sigma_{st}(v)}{sigma_{st}}$.\n\n\nParameters\n\n\ng: ASimpleGraph     A Graph, directed or undirected.\n\n\nk: Integer, optional     Use \nk\n nodes sample to estimate the betweenness centrality. If none,     betweenness centrality is computed using the \nn\n nodes in the graph.\n\n\nnormalize: bool, optional     If true, the betweenness values are normalized by the total number     of possible distinct paths between all pairs in the graphs. For an undirected graph,     this number if \n((n-1)*(n-2))/2\n and for a directed graph, \n(n-1)*(n-2)\n     where \nn\n is the number of nodes in the graph.\n\n\nendpoints: bool, optional     If true, endpoints are included in the shortest path count.\n\n\nReturns\n\n\nbetweenness: Array{Float64}     Betweenness centrality value per node id.\n\n\nReferences\n\n\n[1] Brandes 2001 & Brandes 2008\n\n\nsource\n\n\n#\n\n\nFatGraphs.closeness_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ncloseness centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nFatGraphs.in_degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nFatGraphs.out_degree_centrality\n \u2014 \nMethod\n.\n\n\nCalculates the \ndegree centrality\n of the graph \ng\n, with optional (default) normalization.\n\n\nsource\n\n\n#\n\n\nFatGraphs.katz_centrality\n \u2014 \nFunction\n.\n\n\nCalculates the \nKatz centrality\n of the graph \ng\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.pagerank\n \u2014 \nFunction\n.\n\n\nCalculates the \nPageRank\n of the graph \ng\n. Can optionally specify a different damping factor (\n\u03b1\n), number of iterations (\nn\n), and convergence threshold (\n\u03f5\n). If convergence is not reached within \nn\n iterations, an error will be returned.\n\n\nsource",
            "title": "Centrality Measures"
        },
        {
            "location": "/centrality/#centrality-measures",
            "text": "Centrality measures  describe the importance of a vertex to the rest of the graph using some set of criteria. Centrality measures implemented in  FatGraphs.jl  include the following:   FatGraphs.betweenness_centrality  FatGraphs.closeness_centrality  FatGraphs.degree_centrality  FatGraphs.in_degree_centrality  FatGraphs.katz_centrality  FatGraphs.out_degree_centrality  FatGraphs.pagerank   #  FatGraphs.betweenness_centrality  \u2014  Function .  betweenness_centrality(g, k=0; normalize=true, endpoints=false)  Calculates the  betweenness centrality  of the graph  g , or, optionally, of a random subset of  k  vertices. Can optionally include endpoints in the calculations. Normalization is enabled by default.  Betweenness centrality is defined as:  $bc(v) = \frac{1}{mathcal{N}} sum_{s  eq t  eq v}         \frac{sigma_{st}(v)}{sigma_{st}}$.  Parameters  g: ASimpleGraph     A Graph, directed or undirected.  k: Integer, optional     Use  k  nodes sample to estimate the betweenness centrality. If none,     betweenness centrality is computed using the  n  nodes in the graph.  normalize: bool, optional     If true, the betweenness values are normalized by the total number     of possible distinct paths between all pairs in the graphs. For an undirected graph,     this number if  ((n-1)*(n-2))/2  and for a directed graph,  (n-1)*(n-2)      where  n  is the number of nodes in the graph.  endpoints: bool, optional     If true, endpoints are included in the shortest path count.  Returns  betweenness: Array{Float64}     Betweenness centrality value per node id.  References  [1] Brandes 2001 & Brandes 2008  source  #  FatGraphs.closeness_centrality  \u2014  Method .  Calculates the  closeness centrality  of the graph  g .  source  #  FatGraphs.degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  FatGraphs.in_degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  FatGraphs.out_degree_centrality  \u2014  Method .  Calculates the  degree centrality  of the graph  g , with optional (default) normalization.  source  #  FatGraphs.katz_centrality  \u2014  Function .  Calculates the  Katz centrality  of the graph  g .  source  #  FatGraphs.pagerank  \u2014  Function .  Calculates the  PageRank  of the graph  g . Can optionally specify a different damping factor ( \u03b1 ), number of iterations ( n ), and convergence threshold ( \u03f5 ). If convergence is not reached within  n  iterations, an error will be returned.  source",
            "title": "Centrality Measures"
        },
        {
            "location": "/community/",
            "text": "Community Structures\n\n\nFatGraphs.jl\n contains many algorithm to detect and analyze community structures in graphs.\n\n\n#\n\n\nFatGraphs.global_clustering_coefficient\n \u2014 \nMethod\n.\n\n\nglobal_clustering_coefficient(g)\n\n\n\n\nComputes the \nglobal clustering coefficient\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.local_clustering\n \u2014 \nFunction\n.\n\n\nlocal_clustering(g, vlist = vertices(g))\n\n\n\n\nReturns two vectors, respectively containing  the first and second result of \nlocal_clustering_coefficients(g, v)\n for each \nv\n in \nvlist\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.local_clustering\n \u2014 \nMethod\n.\n\n\nlocal_clustering(g, v)\n\n\n\n\nReturns a tuple \n(a,b)\n, where \na\n is the number of triangles in the neighborhood of \nv\n and \nb\n is the maximum number of possible triangles. It is related to the local clustering coefficient  by \nr=a/b\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.local_clustering_coefficient\n \u2014 \nFunction\n.\n\n\nlocal_clustering_coefficient(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing  the \nlocal clustering coefficients\n for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.local_clustering_coefficient\n \u2014 \nMethod\n.\n\n\nlocal_clustering_coefficient(g, v)\n\n\n\n\nComputes the \nlocal clustering coefficient\n for node \nv\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.triangles\n \u2014 \nFunction\n.\n\n\ntriangles(g, vlist = vertices(g))\n\n\n\n\nReturns a vector containing the number of triangles for vertices \nvlist\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.triangles\n \u2014 \nMethod\n.\n\n\ntriangles(g, v)\n\n\n\n\nReturns the number of triangles in the neighborhood for node \nv\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.core_periphery_deg\n \u2014 \nMethod\n.\n\n\ncore_periphery_deg(g)\n\n\n\n\nA simple degree-based core-periphery detection algorithm (see \nLip\n). Returns the vertex assignments (1 for core and 2 for periphery).\n\n\nsource\n\n\n#\n\n\nFatGraphs.modularity\n \u2014 \nMethod\n.\n\n\nmodularity(g, c)\n\n\n\n\nComputes Newman's modularity \nQ\n for graph \ng\n given the partitioning \nc\n.\n\n\nsource\n\n\n#\n\n\nFatGraphs.maximal_cliques\n \u2014 \nMethod\n.\n\n\nFinds all maximal cliques of an undirected graph.\n\n\njulia> using FatGraphs\njulia> g = Graph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.community_detection_bethe\n \u2014 \nFunction\n.\n\n\ncommunity_detection_bethe(g::AGraph, k=-1; kmax=15)\n\n\n\n\nCommunity detection using the spectral properties of the Bethe Hessian matrix associated to \ng\n (see \nSaade et al.\n). \nk\n is the number of community to detect. If omitted or if \nk<1\n the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by \nkmax\n. Returns a vector containing the vertex assignments.\n\n\nsource\n\n\n#\n\n\nFatGraphs.community_detection_nback\n \u2014 \nMethod\n.\n\n\ncommunity_detection_nback(g::AGraph, k::Int)\n\n\n\n\nCommunity detection using the spectral properties of the non-backtracking matrix of \ng\n (see \nKrzakala et al.\n).\n\n\ng\n: imput Graph \nk\n: number of communities to detect\n\n\nreturn : array containing vertex assignments\n\n\nsource\n\n\n#\n\n\nFatGraphs.label_propagation\n \u2014 \nMethod\n.\n\n\nCommunity detection using the label propagation algorithm (see \nRaghavan et al.\n). \ng\n: input Graph \nmaxiter\n: maximum number of iterations return : vertex assignments and the convergence history\n\n\nsource\n\n\n#\n\n\nFatGraphs.nonbacktrack_embedding\n \u2014 \nMethod\n.\n\n\nSpectral embedding of the non-backtracking matrix of \ng\n (see \nKrzakala et al.\n).\n\n\ng\n: imput Graph \nk\n: number of dimensions in which to embed\n\n\nreturn : a matrix \u03d5 where \u03d5[:,i] are the coordinates for vertex i.\n\n\nNote does not explicitly construct the \nnon_backtracking_matrix\n. See \nNonbacktracking\n for details.\n\n\nsource",
            "title": "Community Structures"
        },
        {
            "location": "/community/#community-structures",
            "text": "FatGraphs.jl  contains many algorithm to detect and analyze community structures in graphs.  #  FatGraphs.global_clustering_coefficient  \u2014  Method .  global_clustering_coefficient(g)  Computes the  global clustering coefficient .  source  #  FatGraphs.local_clustering  \u2014  Function .  local_clustering(g, vlist = vertices(g))  Returns two vectors, respectively containing  the first and second result of  local_clustering_coefficients(g, v)  for each  v  in  vlist .  source  #  FatGraphs.local_clustering  \u2014  Method .  local_clustering(g, v)  Returns a tuple  (a,b) , where  a  is the number of triangles in the neighborhood of  v  and  b  is the maximum number of possible triangles. It is related to the local clustering coefficient  by  r=a/b .  source  #  FatGraphs.local_clustering_coefficient  \u2014  Function .  local_clustering_coefficient(g, vlist = vertices(g))  Returns a vector containing  the  local clustering coefficients  for vertices  vlist .  source  #  FatGraphs.local_clustering_coefficient  \u2014  Method .  local_clustering_coefficient(g, v)  Computes the  local clustering coefficient  for node  v .  source  #  FatGraphs.triangles  \u2014  Function .  triangles(g, vlist = vertices(g))  Returns a vector containing the number of triangles for vertices  vlist .  source  #  FatGraphs.triangles  \u2014  Method .  triangles(g, v)  Returns the number of triangles in the neighborhood for node  v .  source  #  FatGraphs.core_periphery_deg  \u2014  Method .  core_periphery_deg(g)  A simple degree-based core-periphery detection algorithm (see  Lip ). Returns the vertex assignments (1 for core and 2 for periphery).  source  #  FatGraphs.modularity  \u2014  Method .  modularity(g, c)  Computes Newman's modularity  Q  for graph  g  given the partitioning  c .  source  #  FatGraphs.maximal_cliques  \u2014  Method .  Finds all maximal cliques of an undirected graph.  julia> using FatGraphs\njulia> g = Graph(3)\njulia> add_edge!(g, 1, 2)\njulia> add_edge!(g, 2, 3)\njulia> maximal_cliques(g)\n2-element Array{Array{Int64,N},1}:\n [2,3]\n [2,1]  source  #  FatGraphs.community_detection_bethe  \u2014  Function .  community_detection_bethe(g::AGraph, k=-1; kmax=15)  Community detection using the spectral properties of the Bethe Hessian matrix associated to  g  (see  Saade et al. ).  k  is the number of community to detect. If omitted or if  k<1  the optimal number of communities will be automatically selected. In this case the maximum number of detectable communities is given by  kmax . Returns a vector containing the vertex assignments.  source  #  FatGraphs.community_detection_nback  \u2014  Method .  community_detection_nback(g::AGraph, k::Int)  Community detection using the spectral properties of the non-backtracking matrix of  g  (see  Krzakala et al. ).  g : imput Graph  k : number of communities to detect  return : array containing vertex assignments  source  #  FatGraphs.label_propagation  \u2014  Method .  Community detection using the label propagation algorithm (see  Raghavan et al. ).  g : input Graph  maxiter : maximum number of iterations return : vertex assignments and the convergence history  source  #  FatGraphs.nonbacktrack_embedding  \u2014  Method .  Spectral embedding of the non-backtracking matrix of  g  (see  Krzakala et al. ).  g : imput Graph  k : number of dimensions in which to embed  return : a matrix \u03d5 where \u03d5[:,i] are the coordinates for vertex i.  Note does not explicitly construct the  non_backtracking_matrix . See  Nonbacktracking  for details.  source",
            "title": "Community Structures"
        },
        {
            "location": "/flow/",
            "text": "Flow and Cut\n\n\nFatGraphs.jl\n provides different algorithms for \nmaximum flow\n and minimum cut computations.\n\n\n#\n\n\nFatGraphs.BoykovKolmogorovAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Boykov-Kolmogorov algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.DinicAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use Dinic's algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.EdmondsKarpAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Edmonds\u2013Karp algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.PushRelabelAlgorithm\n \u2014 \nType\n.\n\n\nForces the maximum_flow function to use the Push-Relabel algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.maximum_flow\n \u2014 \nFunction\n.\n\n\nmaximum_flow{T<:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )\n\n\n\n\nGeneric maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.\n\n\nAll algorithms return a tuple with\n\n\n\n\nthe maximum flow\n\n\nthe flow matrix\n\n\nthe labelling associated to the minimum cut\n\n\n\n\nAvailable algorithms are \nDinicAlgorithm\n, \nEdmondsKarpAlgorithm\n, \nBoykovKolmogorovAlgorithm\n and \nPushRelabelAlgorithm\n.\n\n\nTime complexity is O(V\u00b2\u221aE) for the push relabel algorithm.\n\n\nUsage Example:\n\n\n\n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())\n\n\n\n\nsource\n\n\n#\n\n\nFatGraphs.minimum_cut\n \u2014 \nMethod\n.\n\n\nminimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)\n\n\n\n\nFinds the \ns-t cut\n of minimal weight according to the \ncapacities\n matrix. The solution is found trhough a maximal flow algorithm. See \nmaximum_flow\n for the optional arguments.\n\n\nReturns a triple \n(f, cut, labels)\n, where \nf\n is the weight of the cut, \ncut\n is a vector of the edges in the cut, and \nlabels\n gives a partitioning of the vertices in two sets, according to the cut.\n\n\nsource\n\n\n#\n\n\nFatGraphs.ExtendedMultirouteFlowAlgorithm\n \u2014 \nType\n.\n\n\nForces the multiroute_flow function to use the Extended Multiroute Flow algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.KishimotoAlgorithm\n \u2014 \nType\n.\n\n\nForces the multiroute_flow function to use the Kishimoto algorithm.\n\n\nsource\n\n\n#\n\n\nFatGraphs.multiroute_flow\n \u2014 \nFunction\n.\n\n\nThe generic multiroute_flow function will output three kinds of results:\n\n\n\n\nWhen the number of routes is 0 or non-specified, the set of breaking points of\n\n\n\n\nthe multiroute flow is returned.\n\n\n\n\nWhen the input is limited to a set of breaking points and a route value k,\n\n\n\n\nonly the value of the k-route flow is returned\n\n\n\n\nOtherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the\n\n\n\n\nmax-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.\n\n\nWhen the input is a network, it requires the following arguments:\n\n\n\n\nflow_graph::ADiGraph                   # the input graph\n\n\nsource::Int                           # the source vertex\n\n\ntarget::Int                           # the target vertex\n\n\ncapacity_matrix::AbstractArray{T, 2}  # edge flow capacities with T<:Real\n\n\nflow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm\n\n\nmrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm\n\n\nroutes::R<:Real                       # keyword argument for the number of routes\n\n\n\n\nWhen the input is only the set of (breaking) points and the number of route, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points\n\n\nroutes::R<:Real,                             # number of routes\n\n\n\n\nWhen the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:\n\n\n\n\nbreakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1<:Real)\n\n\nroutes::R<:Real                            # number of routes\n\n\nflow_graph::ADiGraph                        # the input graph\n\n\nsource::Int                                # the source vertex\n\n\ntarget::Int                                # the target vertex\n\n\ncapacity_matrix::AbstractArray{T2, 2}      # optional edge flow capacities (T2<:Real)\n\n\nflow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm\n\n\n\n\nThe function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.\n\n\nThe mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:\n\n\n\n\nThe number of routes is non-integer\n\n\nThe number of routes is 0 or non-specified\n\n\n\n\nUsage Example :\n\n\n(please consult the  max_flow section for options about flow_algorithm and capacity_matrix)\n\n\n\n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)\n\n\n\n\n\nsource",
            "title": "Flow and Cut"
        },
        {
            "location": "/flow/#flow-and-cut",
            "text": "FatGraphs.jl  provides different algorithms for  maximum flow  and minimum cut computations.  #  FatGraphs.BoykovKolmogorovAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Boykov-Kolmogorov algorithm.  source  #  FatGraphs.DinicAlgorithm  \u2014  Type .  Forces the maximum_flow function to use Dinic's algorithm.  source  #  FatGraphs.EdmondsKarpAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Edmonds\u2013Karp algorithm.  source  #  FatGraphs.PushRelabelAlgorithm  \u2014  Type .  Forces the maximum_flow function to use the Push-Relabel algorithm.  source  #  FatGraphs.maximum_flow  \u2014  Function .  maximum_flow{T<:Number}(\n                    g::ADiGraph,\n                    source::Int,\n                    target::Int,\n                    capacity_matrix::AbstractMatrix{T} =\n                        DefaultCapacity(g);\n                    algorithm::AbstractFlowAlgorithm  =\n                        PushRelabelAlgorithm(),\n                    restriction::T = zero(T)\n                )  Generic maximum_flow function. The function defaults to the Push-Relabel (also called Preflow) algorithm. Alternatively, the algorithm to be used can also be specified through a keyword argument. A default capacity of 1 is assumed for each link if no capacity matrix is provided. If the restriction is bigger than 0, it is applied to capacity_matrix.  All algorithms return a tuple with   the maximum flow  the flow matrix  the labelling associated to the minimum cut   Available algorithms are  DinicAlgorithm ,  EdmondsKarpAlgorithm ,  BoykovKolmogorovAlgorithm  and  PushRelabelAlgorithm .  Time complexity is O(V\u00b2\u221aE) for the push relabel algorithm.  Usage Example:  \n# Create a flow-graph and a capacity matrix\ng = DiGraph(8)\nflow_edges = [\n    (1,2,10),(1,3,5),(1,4,15),(2,3,4),(2,5,9),\n    (2,6,15),(3,4,4),(3,6,8),(4,7,16),(5,6,15),\n    (5,8,10),(6,7,15),(6,8,10),(7,3,6),(7,8,10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(g, u, v)\n    capacity_matrix[u,v] = f\nend\n\n# Run default maximum_flow without the capacity_matrix (assumes capacity 1. on each edge).\nf, F, labels = maximum_flow(g, 1, 8)\n\n# Run Endmonds-Karp algorithm\nf, F, labels = maximum_flow(g,1,8,capacity_matrix,algorithm=EdmondsKarpAlgorithm())  source  #  FatGraphs.minimum_cut  \u2014  Method .  minimum_cut(g, s, t, capacity_matrix=DefaultCapacity(); kws...)  Finds the  s-t cut  of minimal weight according to the  capacities  matrix. The solution is found trhough a maximal flow algorithm. See  maximum_flow  for the optional arguments.  Returns a triple  (f, cut, labels) , where  f  is the weight of the cut,  cut  is a vector of the edges in the cut, and  labels  gives a partitioning of the vertices in two sets, according to the cut.  source  #  FatGraphs.ExtendedMultirouteFlowAlgorithm  \u2014  Type .  Forces the multiroute_flow function to use the Extended Multiroute Flow algorithm.  source  #  FatGraphs.KishimotoAlgorithm  \u2014  Type .  Forces the multiroute_flow function to use the Kishimoto algorithm.  source  #  FatGraphs.multiroute_flow  \u2014  Function .  The generic multiroute_flow function will output three kinds of results:   When the number of routes is 0 or non-specified, the set of breaking points of   the multiroute flow is returned.   When the input is limited to a set of breaking points and a route value k,   only the value of the k-route flow is returned   Otherwise, a tuple with 1) the maximum flow and 2) the flow matrix. When the   max-flow subroutine is the Boykov-Kolmogorov algorithm, the associated mincut is returned as a third output.  When the input is a network, it requires the following arguments:   flow_graph::ADiGraph                   # the input graph  source::Int                           # the source vertex  target::Int                           # the target vertex  capacity_matrix::AbstractArray{T, 2}  # edge flow capacities with T<:Real  flow_algorithm::AbstractFlowAlgorithm # keyword argument for flow algorithm  mrf_algorithm::AbstractFlowAlgorithm  # keyword argument for multiroute flow algorithm  routes::R<:Real                       # keyword argument for the number of routes   When the input is only the set of (breaking) points and the number of route, it requires the following arguments:   breakingpoints::Vector{Tuple{T, T, Int}},    # vector of breaking points  routes::R<:Real,                             # number of routes   When the input is the set of (breaking) points, the number of routes, and the network descriptors, it requires the following arguments:   breakingpoints::Vector{Tuple{T1, T1, Int}} # vector of breaking points (T1<:Real)  routes::R<:Real                            # number of routes  flow_graph::ADiGraph                        # the input graph  source::Int                                # the source vertex  target::Int                                # the target vertex  capacity_matrix::AbstractArray{T2, 2}      # optional edge flow capacities (T2<:Real)  flow_algorithm::AbstractFlowAlgorithm      # keyword argument for algorithm   The function defaults to the Push-relabel (classical flow) and Kishimoto (multiroute) algorithms. Alternatively, the algorithms to be used can also be specified through  keyword arguments. A default capacity of 1 is assumed for each link if no capacity matrix is provided.  The mrf_algorithm keyword is inforced to Extended Multiroute Flow in the following cases:   The number of routes is non-integer  The number of routes is 0 or non-specified   Usage Example :  (please consult the  max_flow section for options about flow_algorithm and capacity_matrix)  \n# Create a flow-graph and a capacity matrix\nflow_graph = DiGraph(8)\nflow_edges = [\n    (1, 2, 10), (1, 3, 5),  (1, 4, 15), (2, 3, 4),  (2, 5, 9),\n    (2, 6, 15), (3, 4, 4),  (3, 6, 8),  (4, 7, 16), (5, 6, 15),\n    (5, 8, 10), (6, 7, 15), (6, 8, 10), (7, 3, 6),  (7, 8, 10)\n]\ncapacity_matrix = zeros(Int, 8, 8)\nfor e in flow_edges\n    u, v, f = e\n    add_edge!(flow_graph, u, v)\n    capacity_matrix[u, v] = f\nend\n\n# Run default multiroute_flow with an integer number of routes = 2\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 2)\n\n# Run default multiroute_flow with a noninteger number of routes = 1.5\nf, F = multiroute_flow(flow_graph, 1, 8, capacity_matrix, routes = 1.5)\n\n# Run default multiroute_flow for all the breaking points values\npoints = multiroute_flow(flow_graph, 1, 8, capacity_matrix)\n# Then run multiroute flow algorithm for any positive number of routes\nf, F = multiroute_flow(points, 1.5)\nf = multiroute_flow(points, 1.5, valueonly = true)\n\n# Run multiroute flow algorithm using Boykov-Kolmogorov algorithm as max_flow routine\nf, F, labels = multiroute_flow(flow_graph, 1, 8, capacity_matrix,\n               algorithm = BoykovKolmogorovAlgorithm(), routes = 2)  source",
            "title": "Flow and Cut"
        },
        {
            "location": "/matching/",
            "text": "Matching\n\n\nAlgorithms for the \noptimal matching problem\n.\n\n\n#\n\n\nFatGraphs.minimum_weight_perfect_matching\n \u2014 \nFunction\n.\n\n\nminimum_weight_perfect_matching{T<:Real, E}(g, w::Dict{E,T} [,cutoff])\n\n\n\n\nGiven a graph \ng\n and an edgemap \nw\n containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly \nnv(g)/2\n edges.\n\n\nEdges in \ng\n not present in \nw\n will not be considered for the matching.\n\n\nThis function relies on the BlossomV.jl package, a julia wrapper around Kolmogorov's BlossomV algorithm.\n\n\nEventually a \ncutoff\n argument can be given, to the reduce computational time excluding edges with weights higher than the cutoff.\n\n\nThe returned object is of type \nMatchingResult\n.\n\n\nIn case of error try to change the optional argument \ntmaxscale\n (default is \ntmaxscale=10\n).\n\n\nsource",
            "title": "Matching"
        },
        {
            "location": "/matching/#matching",
            "text": "Algorithms for the  optimal matching problem .  #  FatGraphs.minimum_weight_perfect_matching  \u2014  Function .  minimum_weight_perfect_matching{T<:Real, E}(g, w::Dict{E,T} [,cutoff])  Given a graph  g  and an edgemap  w  containing weights associated to edges, returns a matching with the mimimum total weight among the ones containing exactly  nv(g)/2  edges.  Edges in  g  not present in  w  will not be considered for the matching.  This function relies on the BlossomV.jl package, a julia wrapper around Kolmogorov's BlossomV algorithm.  Eventually a  cutoff  argument can be given, to the reduce computational time excluding edges with weights higher than the cutoff.  The returned object is of type  MatchingResult .  In case of error try to change the optional argument  tmaxscale  (default is  tmaxscale=10 ).  source",
            "title": "Matching"
        },
        {
            "location": "/spanningtrees/",
            "text": "Spanning Trees\n\n\n#\n\n\nFatGraphs.count_spanning_trees\n \u2014 \nMethod\n.\n\n\ncount_spanning_trees(g::AGraph)\n\n\n\n\nReturns the number of spanning trees of \ng\n, computed through \nKirchhoff's theorem\n. The return type is a float, since the number can be very large.\n\n\nsource\n\n\n#\n\n\nFatGraphs.minimum_spanning_tree\n \u2014 \nFunction\n.\n\n\nminimum_spanning_tree{T<:Real}(\n    g, distmx::AbstractArray{T, 2} = DefaultDistance()\n)\n\n\n\n\nPerforms \nKruskal's algorithm\n on a connected, undirected graph \ng\n, having adjacency matrix \ndistmx\n, and computes minimum spanning tree. Returns a \nVector{KruskalHeapEntry}\n, that contains the containing edges and its weights.\n\n\nsource",
            "title": "Spanning Trees"
        },
        {
            "location": "/spanningtrees/#spanning-trees",
            "text": "#  FatGraphs.count_spanning_trees  \u2014  Method .  count_spanning_trees(g::AGraph)  Returns the number of spanning trees of  g , computed through  Kirchhoff's theorem . The return type is a float, since the number can be very large.  source  #  FatGraphs.minimum_spanning_tree  \u2014  Function .  minimum_spanning_tree{T<:Real}(\n    g, distmx::AbstractArray{T, 2} = DefaultDistance()\n)  Performs  Kruskal's algorithm  on a connected, undirected graph  g , having adjacency matrix  distmx , and computes minimum spanning tree. Returns a  Vector{KruskalHeapEntry} , that contains the containing edges and its weights.  source",
            "title": "Spanning Trees"
        },
        {
            "location": "/integration/",
            "text": "Integration with other packages\n\n\nFatGraphs.jl\n's integration with other Julia packages is designed to be straightforward. Here are a few examples.\n\n\n\n\nGraphs.jl\n\n\nCreating a Graphs.jl \nsimple_graph\n is easy:\n\n\njulia> s = simple_graph(nv(g), is_directed=FatGraphs.is_directed(g))\njulia> for e in FatGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end\n\n\n\n\n\n\nGraphLayout.jl\n\n\nThis excellent graph visualization package can be used with \nFatGraphs.jl\n as follows:\n\n\njulia> g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia> loc_x, loc_y = layout_spring_adj(am)\njulia> draw_layout_adj(am, loc_x, loc_y, filename=\"wheel10.svg\")\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nTikzGraphs.jl\n\n\nAnother nice graph visualization package. (\nTikzPictures.jl\n required to render/save):\n\n\njulia> g = WheelGraph(10); t = plot(g)\n\njulia> save(SVG(\"wheel10.svg\"), t)\n\n\n\n\nproducing a graph like this:\n\n\n\n\n\n\nGraphPlot.jl\n\n\nAnother graph visualization package that is very simple to use. \nCompose.jl\n is required for most rendering functionality:\n\n\njulia> using GraphPlot, Compose\n\njulia> g = WheelGraph(10)\n\njulia> draw(PNG(\"/tmp/wheel10.png\", 16cm, 16cm), gplot(g))\n\n\n\n\n\n\nMetis.jl\n\n\nThe Metis graph partitioning package can interface with \nFatGraphs.jl\n:\n\n\njulia> using FatGraphs\n\njulia> g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia> partGraphKway(g, 6)  # 6 partitions\n\n\n\n\nNetworkViz.jl\n NetworkViz.jl is tightly coupled with \nFatGraphs.jl\n. Graphs can be visualized in 2D as well as 3D using \nThreeJS.jl\n and \nEscher.jl\n.\n\n\n#Run this code in Escher\n\nusing NetworkViz\nusing FatGraphs\n\nmain(window) = begin\n  push!(window.assets, \"widgets\")\n  push!(window.assets,(\"ThreeJS\",\"threejs\"))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend\n\n\n\n\nThe above code produces the following output:",
            "title": "Integration with other packages"
        },
        {
            "location": "/integration/#integration-with-other-packages",
            "text": "FatGraphs.jl 's integration with other Julia packages is designed to be straightforward. Here are a few examples.",
            "title": "Integration with other packages"
        },
        {
            "location": "/integration/#graphsjl",
            "text": "Creating a Graphs.jl  simple_graph  is easy:  julia> s = simple_graph(nv(g), is_directed=FatGraphs.is_directed(g))\njulia> for e in FatGraphs.edges(g)\n           add_edge!(s,src(e), dst(e))\n       end",
            "title": "Graphs.jl"
        },
        {
            "location": "/integration/#graphlayoutjl",
            "text": "This excellent graph visualization package can be used with  FatGraphs.jl  as follows:  julia> g = WheelGraph(10); am = full(adjacency_matrix(g))\njulia> loc_x, loc_y = layout_spring_adj(am)\njulia> draw_layout_adj(am, loc_x, loc_y, filename=\"wheel10.svg\")  producing a graph like this:",
            "title": "GraphLayout.jl"
        },
        {
            "location": "/integration/#tikzgraphsjl",
            "text": "Another nice graph visualization package. ( TikzPictures.jl  required to render/save):  julia> g = WheelGraph(10); t = plot(g)\n\njulia> save(SVG(\"wheel10.svg\"), t)  producing a graph like this:",
            "title": "TikzGraphs.jl"
        },
        {
            "location": "/integration/#graphplotjl",
            "text": "Another graph visualization package that is very simple to use.  Compose.jl  is required for most rendering functionality:  julia> using GraphPlot, Compose\n\njulia> g = WheelGraph(10)\n\njulia> draw(PNG(\"/tmp/wheel10.png\", 16cm, 16cm), gplot(g))",
            "title": "GraphPlot.jl"
        },
        {
            "location": "/integration/#metisjl",
            "text": "The Metis graph partitioning package can interface with  FatGraphs.jl :  julia> using FatGraphs\n\njulia> g = Graph(100,1000)\n{100, 1000} undirected graph\n\njulia> partGraphKway(g, 6)  # 6 partitions",
            "title": "Metis.jl"
        },
        {
            "location": "/integration/#networkvizjl-networkvizjl-is-tightly-coupled-with-fatgraphsjl-graphs-can-be-visualized-in-2d-as-well-as-3d-using-threejsjl-and-escherjl",
            "text": "#Run this code in Escher\n\nusing NetworkViz\nusing FatGraphs\n\nmain(window) = begin\n  push!(window.assets, \"widgets\")\n  push!(window.assets,(\"ThreeJS\",\"threejs\"))\n  g = CompleteGraph(10)\n  drawGraph(g)\nend  The above code produces the following output:",
            "title": "NetworkViz.jl NetworkViz.jl is tightly coupled with FatGraphs.jl. Graphs can be visualized in 2D as well as 3D using ThreeJS.jl and Escher.jl."
        },
        {
            "location": "/contributing/",
            "text": "We welcome all possible contributors and ask that you read these guidelines before starting to work on this project. Following these guidelines will reduce friction and improve the speed at which your code gets merged.\n\n\n\n\nBug reports\n\n\nIf you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.\n\n\nPlease include version numbers of all relevant libraries and Julia itself.\n\n\n\n\nDevelopment guidelines\n\n\n\n\nPRs should contain one logical enhancement to the codebase.\n\n\nSquash commits in a PR.\n\n\nOpen an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).\n\n\n\n\nMinimize dependencies on external packages, and avoid introducing new dependencies. In general,\n\n\n\n\nPRs introducing dependencies on core Julia packages are ok.\n\n\nPRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.\n\n\nPRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).\n\n\nPut type assertions on all function arguments (use abstract types, Union, or Any if necessary).\n\n\nIf the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).\n\n\nTake steps to ensure that code works on graphs with multiple connected components efficiently.\n\n\nCorrectness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.\n\n\nWe can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.\n\n\nStyle point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated (\ne.g.\n, \ncondition && error(\"message\")\n is good; \ncondition && i += 1\n is not).\n\n\nWhen possible write code to reuse memory. For example:\n\n\n\n\n\n\n\n\nfunction f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nshould be rewritten as two functions\n\n\nfunction f(g::AS, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractArray{Int,1}, g::AS, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend\n\n\n\n\nThis allows us to reuse the memory and improve performance.",
            "title": "Contributing"
        },
        {
            "location": "/contributing/#bug-reports",
            "text": "If you notice code that is incorrect/crashes/too slow please file a bug report. The report should be raised as a github issue with a minimal working example that reproduces the error message. The example should include any data needed. If the problem is incorrectness, then please post the correct result along with an incorrect result.  Please include version numbers of all relevant libraries and Julia itself.",
            "title": "Bug reports"
        },
        {
            "location": "/contributing/#development-guidelines",
            "text": "PRs should contain one logical enhancement to the codebase.  Squash commits in a PR.  Open an issue to discuss a feature before you start coding (this maximizes the likelihood of patch acceptance).   Minimize dependencies on external packages, and avoid introducing new dependencies. In general,   PRs introducing dependencies on core Julia packages are ok.  PRs introducing dependencies on non-core \"leaf\" packages (no subdependencies except for core Julia packages) are less ok.  PRs introducing dependencies on non-core non-leaf packages require strict scrutiny and will likely not be accepted without some compelling reason (urgent bugfix or much-needed functionality).  Put type assertions on all function arguments (use abstract types, Union, or Any if necessary).  If the algorithm was presented in a paper, include a reference to the paper (i.e. a proper academic citation along with an eprint link).  Take steps to ensure that code works on graphs with multiple connected components efficiently.  Correctness is a necessary requirement; efficiency is desirable. Once you have a correct implementation, make a PR so we can help improve performance.  We can accept code that does not work for directed graphs as long as it comes with an explanation of what it would take to make it work for directed graphs.  Style point: prefer the short circuiting conditional over if/else when convenient, and where state is not explicitly being mutated ( e.g. ,  condition && error(\"message\")  is good;  condition && i += 1  is not).  When possible write code to reuse memory. For example:     function f(g, v)\n    storage = Vector{Int}(nv(g))\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  should be rewritten as two functions  function f(g::AS, v::Integer)\n    storage = Vector{Int}(nv(g))\n    return inner!(storage, g, v)\nend\n\nfunction inner!(storage::AbstractArray{Int,1}, g::AS, v::Integer)\n    # some code operating on storage, g, and v.\n    for i in 1:nv(g)\n        storage[i] = v-i\n    end\n    return sum(storage)\nend  This allows us to reuse the memory and improve performance.",
            "title": "Development guidelines"
        },
        {
            "location": "/license/",
            "text": "The FatGraphs.jl package is licensed under the MIT \"Expat\" License:\n\n\n\n\nCopyright (c) 2016: Carlo Lucibello and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n\n\nFatGraphs uses code derived from and/or inspired by the following packages:\n\n\nLightGraphs.jl:\n\n\n\n\nCopyright (c) 2015: Seth Bromberger and other contributors.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nNetworkX:\n\n\n\n\nCopyright (C) 2004-2012, NetworkX Developers Aric Hagberg \nhagberg@lanl.gov\n Dan Schult \ndschult@colgate.edu\n Pieter Swart \nswart@lanl.gov\n All rights reserved.\n\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n\n\n\nRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n\nRedistributions in binary form must reproduce the above with the distribution.\n\n\nNeither the name of the NetworkX Developers nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.\n\n\n\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n\n\nGraphs.jl:\n\n\n\n\nCopyright (c) 2012: John Myles White and other contributors.\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.",
            "title": "License Information"
        }
    ]
}